diff --git a/src/java/android/telephony/gsm/SmsManager.java b/src/java/android/telephony/gsm/SmsManager.java
index 777802a..41c5adc 100644
--- a/src/java/android/telephony/gsm/SmsManager.java
+++ b/src/java/android/telephony/gsm/SmsManager.java
@@ -76,6 +76,7 @@ import java.util.ArrayList;
     public final void sendTextMessage(
             String destinationAddress, String scAddress, String text,
             PendingIntent sentIntent, PendingIntent deliveryIntent) {
+        android.util.SeempLog.record_str(75, destinationAddress);
         mSmsMgrProxy.sendTextMessage(destinationAddress, scAddress, text,
                 sentIntent, deliveryIntent);
     }
@@ -128,6 +129,7 @@ import java.util.ArrayList;
     public final void sendMultipartTextMessage(
             String destinationAddress, String scAddress, ArrayList<String> parts,
             ArrayList<PendingIntent> sentIntents, ArrayList<PendingIntent> deliveryIntents) {
+        android.util.SeempLog.record_str(77, destinationAddress);
         mSmsMgrProxy.sendMultipartTextMessage(destinationAddress, scAddress, parts,
                 sentIntents, deliveryIntents);
     }
@@ -161,6 +163,7 @@ import java.util.ArrayList;
     public final void sendDataMessage(
             String destinationAddress, String scAddress, short destinationPort,
             byte[] data, PendingIntent sentIntent, PendingIntent deliveryIntent) {
+        android.util.SeempLog.record_str(73, destinationAddress);
         mSmsMgrProxy.sendDataMessage(destinationAddress, scAddress, destinationPort,
                 data, sentIntent, deliveryIntent);
     }
@@ -178,6 +181,7 @@ import java.util.ArrayList;
      */
     @Deprecated
     public final boolean copyMessageToSim(byte[] smsc, byte[] pdu, int status) {
+        android.util.SeempLog.record(82);
         return mSmsMgrProxy.copyMessageToIcc(smsc, pdu, status);
     }
 
@@ -191,6 +195,7 @@ import java.util.ArrayList;
      */
     @Deprecated
     public final boolean deleteMessageFromSim(int messageIndex) {
+        android.util.SeempLog.record(83);
         return mSmsMgrProxy.deleteMessageFromIcc(messageIndex);
     }
 
@@ -208,6 +213,7 @@ import java.util.ArrayList;
      */
     @Deprecated
     public final boolean updateMessageOnSim(int messageIndex, int newStatus, byte[] pdu) {
+        android.util.SeempLog.record(84);
         return mSmsMgrProxy.updateMessageOnIcc(messageIndex, newStatus, pdu);
     }
 
@@ -219,6 +225,7 @@ import java.util.ArrayList;
      */
     @Deprecated
     public final ArrayList<android.telephony.SmsMessage> getAllMessagesFromSim() {
+        android.util.SeempLog.record(85);
         return android.telephony.SmsManager.getDefault().getAllMessagesFromIcc();
     }
 
diff --git a/src/java/com/android/internal/telephony/BaseCommands.java b/src/java/com/android/internal/telephony/BaseCommands.java
index c8cea5a..7b61364 100644
--- a/src/java/com/android/internal/telephony/BaseCommands.java
+++ b/src/java/com/android/internal/telephony/BaseCommands.java
@@ -879,8 +879,7 @@ public abstract class BaseCommands implements CommandsInterface {
         return mRilVersion;
     }
 
-    public void setUiccSubscription(int slotId, int appIndex, int subId, int subStatus,
-            Message response) {
+    public void setUiccSubscription(int appIndex, boolean activate, Message response) {
     }
 
     public void setDataAllowed(boolean allowed, Message response) {
diff --git a/src/java/com/android/internal/telephony/CallFailCause.java b/src/java/com/android/internal/telephony/CallFailCause.java
old mode 100644
new mode 100755
index acc1432..bd29e78
--- a/src/java/com/android/internal/telephony/CallFailCause.java
+++ b/src/java/com/android/internal/telephony/CallFailCause.java
@@ -149,6 +149,28 @@ public interface CallFailCause {
     int DIAL_MODIFIED_TO_SS   = 245;
     int DIAL_MODIFIED_TO_DIAL = 246;
 
+    //Access class blocked - TS 31.121 5.2.1
+    int ACCESS_CLASS_BLOCKED = 260;
+
+    // Supplementary new disconnect type
+    int NO_ROUTE_TO_DESTINATION = 3;
+    int CALL_FAIL_NO_USER_RESPONDING = 18;
+    int CALL_FAIL_NO_ANSWER_FROM_USER = 20;
+    int PREEMPTION = 25;
+    int CALL_FAIL_DESTINATION_OUT_OF_ORDER = 27;
+    int INVALID_NUMBER = 28;
+    int RESOURCES_UNAVAILABLE_OR_UNSPECIFIED = 47;
+    int INCOMING_CALLS_BARRED_WITHIN_CUG = 55;
+    int BEARER_CAPABILITY_NOT_AUTHORIZED = 57;
+    int SERVICE_OPTION_NOT_AVAILABLE = 63;
+    int ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE = 70;
+    int INVALID_TRANSACTION_IDENTIFIER = 81;
+    int INVALID_TRANSIT_NW_SELECTION = 91;
+    int MESSAGE_TYPE_NON_IMPLEMENTED = 97;
+    int MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 98;
+    int INFORMATION_ELEMENT_NON_EXISTENT = 99;
+    int RECOVERY_ON_TIMER_EXPIRED = 102;
+
     //Emergency Redial
     int EMERGENCY_TEMP_FAILURE = 325;
     int EMERGENCY_PERM_FAILURE = 326;
diff --git a/src/java/com/android/internal/telephony/CarrierServiceStateTracker.java b/src/java/com/android/internal/telephony/CarrierServiceStateTracker.java
index 7f49f28..c7fa870 100644
--- a/src/java/com/android/internal/telephony/CarrierServiceStateTracker.java
+++ b/src/java/com/android/internal/telephony/CarrierServiceStateTracker.java
@@ -20,6 +20,7 @@ import android.app.Notification;
 import android.app.NotificationManager;
 import android.app.PendingIntent;
 import android.content.BroadcastReceiver;
+import android.content.ComponentName;
 import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
@@ -27,6 +28,8 @@ import android.database.ContentObserver;
 import android.os.Handler;
 import android.os.Message;
 import android.os.PersistableBundle;
+import android.os.RemoteException;
+import android.os.ServiceManager;
 import android.provider.Settings;
 import android.telephony.CarrierConfigManager;
 import android.telephony.Rlog;
@@ -36,6 +39,7 @@ import android.telephony.SubscriptionManager.OnSubscriptionsChangedListener;
 
 import com.android.internal.annotations.VisibleForTesting;
 import com.android.internal.telephony.util.NotificationChannelController;
+import org.codeaurora.internal.IExtTelephony;
 
 import java.util.HashMap;
 import java.util.Map;
@@ -399,6 +403,22 @@ public class CarrierServiceStateTracker extends Handler {
         public Notification.Builder getNotificationBuilder() {
             Context context = mPhone.getContext();
             Intent notificationIntent = new Intent(Settings.ACTION_DATA_ROAMING_SETTINGS);
+            IExtTelephony extTelephony =
+                    IExtTelephony.Stub.asInterface(ServiceManager.getService("extphone"));
+            try {
+                if (extTelephony != null &&
+                        extTelephony.isVendorApkAvailable("com.qualcomm.qti.networksetting")) {
+                    notificationIntent.setComponent(
+                            new ComponentName("com.qualcomm.qti.networksetting",
+                            "com.qualcomm.qti.networksetting.MobileNetworkSettings"));
+                } else {
+                    notificationIntent.setComponent(new ComponentName("com.android.phone",
+                            "com.android.phone.MobileNetworkSettings"));
+                }
+            } catch (RemoteException e) {
+                notificationIntent.setComponent(new ComponentName("com.android.phone",
+                        "com.android.phone.MobileNetworkSettings"));
+            }
             notificationIntent.putExtra("expandable", true);
             PendingIntent settingsIntent = PendingIntent.getActivity(context, 0, notificationIntent,
                     PendingIntent.FLAG_ONE_SHOT);
diff --git a/src/java/com/android/internal/telephony/CommandsInterface.java b/src/java/com/android/internal/telephony/CommandsInterface.java
index 9f6ce5e..e46d499 100644
--- a/src/java/com/android/internal/telephony/CommandsInterface.java
+++ b/src/java/com/android/internal/telephony/CommandsInterface.java
@@ -1111,6 +1111,8 @@ public interface CommandsInterface {
      */
     void sendCdmaSms(byte[] pdu, Message response);
 
+    void sendCdmaSms(byte[] pdu, Message response, boolean expectMore);
+
     /**
      * send SMS over IMS with 3GPP/GSM SMS format
      * @param smscPDU is smsc address in PDU form GSM BCD format prefixed
@@ -1952,20 +1954,15 @@ public interface CommandsInterface {
    /**
      * Sets user selected subscription at Modem.
      *
-     * @param slotId
-     *          Slot.
      * @param appIndex
      *          Application index in the card.
-     * @param subId
-     *          Indicates subscription 0 or subscription 1.
-     * @param subStatus
-     *          Activation status, 1 = activate and 0 = deactivate.
+     * @param activate
+     *          Whether to activate or deactivate the subscription.
      * @param result
      *          Callback message contains the information of SUCCESS/FAILURE.
      */
     // FIXME Update the doc and consider modifying the request to make more generic.
-    public void setUiccSubscription(int slotId, int appIndex, int subId, int subStatus,
-            Message result);
+    public void setUiccSubscription(int appIndex, boolean activate, Message result);
 
     /**
      * Tells the modem if data is allowed or not.
diff --git a/src/java/com/android/internal/telephony/Connection.java b/src/java/com/android/internal/telephony/Connection.java
index 62fc5b0..06dcf24 100644
--- a/src/java/com/android/internal/telephony/Connection.java
+++ b/src/java/com/android/internal/telephony/Connection.java
@@ -80,6 +80,11 @@ public abstract class Connection {
          * local device.
          */
         public static final int IS_PULLABLE = 0x00000020;
+
+        /**
+         * For an IMS call, indicates that the peer supports RTT.
+         */
+        public static final int SUPPORTS_RTT_REMOTE = 0x00000040;
     }
 
     /**
@@ -216,6 +221,7 @@ public abstract class Connection {
     private int mPhoneType;
     private boolean mAnsweringDisconnectsActiveCall;
     private boolean mAllowAddCallDuringVideoCall;
+    private boolean mAllowHoldingVideoCall;
 
     /**
      * Used to indicate that this originated from pulling a {@link android.telecom.Connection} with
@@ -909,6 +915,13 @@ public abstract class Connection {
         mAllowAddCallDuringVideoCall = allowAddCallDuringVideoCall;
     }
 
+    public boolean shouldAllowHoldingVideoCall() {
+        return mAllowHoldingVideoCall;
+    }
+
+    public void setAllowHoldingVideoCall(boolean allowHoldingVideoCall) {
+        mAllowHoldingVideoCall = allowHoldingVideoCall;
+    }
     /**
      * Sets whether the connection is the result of an external call which was pulled to the local
      * device.
@@ -1107,6 +1120,18 @@ public abstract class Connection {
     }
 
     /**
+     * Reset the Connection time and Duration
+     */
+    public void resetConnectionTime() {
+        if (mPhoneType == PhoneConstants.PHONE_TYPE_CDMA_LTE ||
+                mPhoneType == PhoneConstants.PHONE_TYPE_CDMA) {
+            mConnectTime = System.currentTimeMillis();
+            mConnectTimeReal = SystemClock.elapsedRealtime();
+            mDuration = 0;
+        }
+    }
+
+    /**
      * Build a human representation of a connection instance, suitable for debugging.
      * Don't log personal stuff unless in debug mode.
      * @return a string representing the internal state of this connection.
diff --git a/src/java/com/android/internal/telephony/GsmCdmaCallTracker.java b/src/java/com/android/internal/telephony/GsmCdmaCallTracker.java
index f4c561c..1b43167 100755
--- a/src/java/com/android/internal/telephony/GsmCdmaCallTracker.java
+++ b/src/java/com/android/internal/telephony/GsmCdmaCallTracker.java
@@ -33,7 +33,6 @@ import android.telephony.CellLocation;
 import android.telephony.DisconnectCause;
 import android.telephony.PhoneNumberUtils;
 import android.telephony.Rlog;
-import android.telephony.ServiceState;
 import android.telephony.TelephonyManager;
 import android.telephony.cdma.CdmaCellLocation;
 import android.telephony.gsm.GsmCellLocation;
@@ -197,6 +196,7 @@ public class GsmCdmaCallTracker extends CallTracker {
         }
 
         if (mPendingMO != null) {
+            mPendingMO.onDisconnect(DisconnectCause.ERROR_UNSPECIFIED);
             mPendingMO.dispose();
         }
 
@@ -613,30 +613,28 @@ public class GsmCdmaCallTracker extends CallTracker {
 
     private boolean canDial() {
         boolean ret;
-        int serviceState = mPhone.getServiceState().getState();
         String disableCall = SystemProperties.get(
                 TelephonyProperties.PROPERTY_DISABLE_CALL, "false");
 
-        ret = (serviceState != ServiceState.STATE_POWER_OFF)
+        ret = mCi.getRadioState().isOn()
                 && mPendingMO == null
                 && !mRingingCall.isRinging()
                 && !disableCall.equals("true")
                 && (!mForegroundCall.getState().isAlive()
-                    || !mBackgroundCall.getState().isAlive()
-                    || (!isPhoneTypeGsm()
-                        && mForegroundCall.getState() == GsmCdmaCall.State.ACTIVE));
+                || !mBackgroundCall.getState().isAlive()
+                || (!isPhoneTypeGsm()
+                && mForegroundCall.getState() == GsmCdmaCall.State.ACTIVE));
 
         if (!ret) {
             log(String.format("canDial is false\n" +
-                            "((serviceState=%d) != ServiceState.STATE_POWER_OFF)::=%s\n" +
+                            "(radio isOn ::=%s\n" +
                             "&& pendingMO == null::=%s\n" +
                             "&& !ringingCall.isRinging()::=%s\n" +
                             "&& !disableCall.equals(\"true\")::=%s\n" +
                             "&& (!foregroundCall.getState().isAlive()::=%s\n" +
                             "   || foregroundCall.getState() == GsmCdmaCall.State.ACTIVE::=%s\n" +
                             "   ||!backgroundCall.getState().isAlive())::=%s)",
-                    serviceState,
-                    serviceState != ServiceState.STATE_POWER_OFF,
+                    mCi.getRadioState().isOn(),
                     mPendingMO == null,
                     !mRingingCall.isRinging(),
                     !disableCall.equals("true"),
@@ -1157,11 +1155,14 @@ public class GsmCdmaCallTracker extends CallTracker {
         }
 
         if (conn == mPendingMO) {
-            // We're hanging up an outgoing call that doesn't have it's
-            // GsmCdma index assigned yet
+            // Re-start Ecm timer when an uncompleted emergency call ends
+            if (mIsEcmTimerCanceled) {
+                handleEcmTimer(GsmCdmaPhone.RESTART_ECM_TIMER);
+            }
 
-            if (Phone.DEBUG_PHONE) log("hangup: set hangupPendingMO to true");
-            mHangupPendingMO = true;
+            // Allow HANGUP to RIL during pending MO is present
+            log("hangup conn with callId '-1' as there is no DIAL response yet ");
+            mCi.hangupConnection(-1, obtainCompleteMessage());
         } else if (!isPhoneTypeGsm()
                 && conn.getCall() == mRingingCall
                 && mRingingCall.getState() == GsmCdmaCall.State.WAITING) {
diff --git a/src/java/com/android/internal/telephony/GsmCdmaConnection.java b/src/java/com/android/internal/telephony/GsmCdmaConnection.java
index c0f67e2..603a0b7 100644
--- a/src/java/com/android/internal/telephony/GsmCdmaConnection.java
+++ b/src/java/com/android/internal/telephony/GsmCdmaConnection.java
@@ -155,9 +155,8 @@ public class GsmCdmaConnection extends Connection {
         mOwner = ct;
         mHandler = new MyHandler(mOwner.getLooper());
 
-        if (isPhoneTypeGsm()) {
-            mDialString = dialString;
-        } else {
+        mDialString = dialString;
+        if (!isPhoneTypeGsm()) {
             Rlog.d(LOG_TAG, "[GsmCdmaConn] GsmCdmaConnection: dialString=" +
                     maskDialString(dialString));
             dialString = formatDialString(dialString);
@@ -441,23 +440,147 @@ public class GsmCdmaConnection extends Connection {
             case CallFailCause.USER_BUSY:
                 return DisconnectCause.BUSY;
 
+            case CallFailCause.NO_ROUTE_TO_DESTINATION:
+                return DisconnectCause.NO_ROUTE_TO_DESTINATION;
+
+            case CallFailCause.CHANNEL_UNACCEPTABLE:
+                return DisconnectCause.CHANNEL_UNACCEPTABLE;
+
+            case CallFailCause.OPERATOR_DETERMINED_BARRING:
+                return DisconnectCause.OPERATOR_DETERMINED_BARRING;
+
+            case CallFailCause.CALL_FAIL_NO_USER_RESPONDING:
+                return DisconnectCause.CALL_FAIL_NO_USER_RESPONDING;
+
+            case CallFailCause.CALL_FAIL_NO_ANSWER_FROM_USER:
+                return DisconnectCause.CALL_FAIL_NO_ANSWER_FROM_USER;
+
+            case CallFailCause.CALL_REJECTED:
+                return DisconnectCause.CALL_REJECTED;
+
+            case CallFailCause.NUMBER_CHANGED:
+                return DisconnectCause.NUMBER_CHANGED;
+
+            case CallFailCause.PREEMPTION:
+                return DisconnectCause.PREEMPTION;
+
+            case CallFailCause.CALL_FAIL_DESTINATION_OUT_OF_ORDER:
+                return DisconnectCause.CALL_FAIL_DESTINATION_OUT_OF_ORDER;
+
+            case CallFailCause.INVALID_NUMBER:
+                return DisconnectCause.INVALID_NUMBER;
+
+            case CallFailCause.FACILITY_REJECTED:
+                return DisconnectCause.FACILITY_REJECTED;
+
+            case CallFailCause.STATUS_ENQUIRY:
+                return DisconnectCause.RESP_TO_STATUS_ENQUIRY;
+
             case CallFailCause.NO_CIRCUIT_AVAIL:
+                return DisconnectCause.NO_CIRCUIT_AVAIL;
+
+            case CallFailCause.NETWORK_OUT_OF_ORDER:
+                return DisconnectCause.NETWORK_OUT_OF_ORDER;
+
             case CallFailCause.TEMPORARY_FAILURE:
+                return DisconnectCause.TEMPORARY_FAILURE;
+
             case CallFailCause.SWITCHING_CONGESTION:
+                return DisconnectCause.SWITCHING_EQUIPMENT_CONGESTION;
+
+            case CallFailCause.ACCESS_INFORMATION_DISCARDED:
+                return DisconnectCause.ACCESS_INFORMATION_DISCARDED;
+
             case CallFailCause.CHANNEL_NOT_AVAIL:
+                return DisconnectCause.REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE;
+
+            case CallFailCause.RESOURCES_UNAVAILABLE_OR_UNSPECIFIED:
+                return DisconnectCause.RESOURCES_UNAVAILABLE_OR_UNSPECIFIED;
+
             case CallFailCause.QOS_NOT_AVAIL:
+                return DisconnectCause.QOS_UNAVAILABLE;
+
+            case CallFailCause.REQUESTED_FACILITY_NOT_SUBSCRIBED:
+                return DisconnectCause.REQUESTED_FACILITY_NOT_SUBSCRIBED;
+
+            case CallFailCause.INCOMING_CALLS_BARRED_WITHIN_CUG:
+                return DisconnectCause.INCOMING_CALLS_BARRED_WITHIN_CUG;
+
+            case CallFailCause.BEARER_CAPABILITY_NOT_AUTHORIZED:
+                return DisconnectCause.BEARER_CAPABILITY_NOT_AUTHORIZED;
+
             case CallFailCause.BEARER_NOT_AVAIL:
-                return DisconnectCause.CONGESTION;
+                return DisconnectCause.BEARER_CAPABILITY_UNAVAILABLE;
+
+            case CallFailCause.SERVICE_OPTION_NOT_AVAILABLE:
+                return DisconnectCause.SERVICE_OPTION_NOT_AVAILABLE;
+
+            case CallFailCause.BEARER_SERVICE_NOT_IMPLEMENTED:
+                return DisconnectCause.BEARER_SERVICE_NOT_IMPLEMENTED;
+
+            case CallFailCause.REQUESTED_FACILITY_NOT_IMPLEMENTED:
+                return DisconnectCause.REQUESTED_FACILITY_NOT_IMPLEMENTED;
+
+            case CallFailCause.ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE:
+                return DisconnectCause.ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE;
+
+            case CallFailCause.SERVICE_OR_OPTION_NOT_IMPLEMENTED:
+                return DisconnectCause.SERVICE_OR_OPTION_NOT_IMPLEMENTED;
+
+            case CallFailCause.INVALID_TRANSACTION_IDENTIFIER:
+                return DisconnectCause.INVALID_TRANSACTION_IDENTIFIER;
+
+            case CallFailCause.USER_NOT_MEMBER_OF_CUG:
+                return DisconnectCause.USER_NOT_MEMBER_OF_CUG;
+
+            case CallFailCause.INCOMPATIBLE_DESTINATION:
+                return DisconnectCause.INCOMPATIBLE_DESTINATION;
+
+            case CallFailCause.INVALID_TRANSIT_NW_SELECTION:
+                return DisconnectCause.INVALID_TRANSIT_NW_SELECTION;
+
+            case CallFailCause.SEMANTICALLY_INCORRECT_MESSAGE:
+                return DisconnectCause.SEMANTICALLY_INCORRECT_MESSAGE;
+
+            case CallFailCause.INVALID_MANDATORY_INFORMATION:
+                return DisconnectCause.INVALID_MANDATORY_INFORMATION;
+
+            case CallFailCause.MESSAGE_TYPE_NON_IMPLEMENTED:
+                return DisconnectCause.MESSAGE_TYPE_NON_IMPLEMENTED;
+
+            case CallFailCause.MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
+                return DisconnectCause.MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE;
+
+            case CallFailCause.INFORMATION_ELEMENT_NON_EXISTENT:
+                return DisconnectCause.INFORMATION_ELEMENT_NON_EXISTENT;
+
+            case CallFailCause.CONDITIONAL_IE_ERROR:
+                return DisconnectCause.CONDITIONAL_IE_ERROR;
+
+            case CallFailCause.MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE:
+                return DisconnectCause.MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE;
+
+            case CallFailCause.RECOVERY_ON_TIMER_EXPIRED:
+                return DisconnectCause.RECOVERY_ON_TIMER_EXPIRED;
+
+            case CallFailCause.PROTOCOL_ERROR_UNSPECIFIED:
+                return DisconnectCause.PROTOCOL_ERROR_UNSPECIFIED;
+
+            case CallFailCause.INTERWORKING_UNSPECIFIED:
+                return DisconnectCause.INTERWORKING_UNSPECIFIED;
+
+            case CallFailCause.NON_SELECTED_USER_CLEARING:
+                return DisconnectCause.NON_SELECTED_USER_CLEARING;
 
             case CallFailCause.EMERGENCY_TEMP_FAILURE:
                 return DisconnectCause.EMERGENCY_TEMP_FAILURE;
+
             case CallFailCause.EMERGENCY_PERM_FAILURE:
                 return DisconnectCause.EMERGENCY_PERM_FAILURE;
 
             case CallFailCause.ACM_LIMIT_EXCEEDED:
                 return DisconnectCause.LIMIT_EXCEEDED;
 
-            case CallFailCause.OPERATOR_DETERMINED_BARRING:
             case CallFailCause.CALL_BARRED:
                 return DisconnectCause.CALL_BARRED;
 
@@ -515,6 +638,7 @@ public class GsmCdmaConnection extends Connection {
             case CallFailCause.USER_ALERTING_NO_ANSWER:
                 return DisconnectCause.TIMED_OUT;
 
+            case CallFailCause.ACCESS_CLASS_BLOCKED:
             case CallFailCause.ERROR_UNSPECIFIED:
             case CallFailCause.NORMAL_CLEARING:
             default:
@@ -549,7 +673,8 @@ public class GsmCdmaConnection extends Connection {
                     }
                 }
                 if (isPhoneTypeGsm()) {
-                    if (causeCode == CallFailCause.ERROR_UNSPECIFIED) {
+                    if (causeCode == CallFailCause.ERROR_UNSPECIFIED ||
+                                   causeCode == CallFailCause.ACCESS_CLASS_BLOCKED ) {
                         if (phone.mSST.mRestrictedState.isCsRestricted()) {
                             return DisconnectCause.CS_RESTRICTED;
                         } else if (phone.mSST.mRestrictedState.isCsEmergencyRestricted()) {
diff --git a/src/java/com/android/internal/telephony/GsmCdmaPhone.java b/src/java/com/android/internal/telephony/GsmCdmaPhone.java
index 7121624..54da840 100644
--- a/src/java/com/android/internal/telephony/GsmCdmaPhone.java
+++ b/src/java/com/android/internal/telephony/GsmCdmaPhone.java
@@ -99,6 +99,8 @@ import java.util.List;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
+import org.codeaurora.ims.QtiCallConstants;
+
 /**
  * {@hide}
  */
@@ -125,6 +127,8 @@ public class GsmCdmaPhone extends Phone {
     /** List of Registrants to receive Supplementary Service Notifications. */
     private RegistrantList mSsnRegistrants = new RegistrantList();
 
+    private static final int IMEI_14_DIGIT = 14;
+
     //CDMA
     // Default Emergency Callback Mode exit timer
     private static final int DEFAULT_ECM_EXIT_TIMER_VALUE = 300000;
@@ -236,7 +240,10 @@ public class GsmCdmaPhone extends Phone {
         @Override
         public void onReceive(Context context, Intent intent) {
             Rlog.d(LOG_TAG, "mBroadcastReceiver: action " + intent.getAction());
-            if (intent.getAction().equals(CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED)) {
+            if (intent.getAction().equals(CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED) &&
+                    intent.getExtras() != null &&
+                    intent.getExtras().getInt(CarrierConfigManager.EXTRA_SLOT_INDEX,
+                    SubscriptionManager.INVALID_SIM_SLOT_INDEX) == mPhoneId) {
                 sendMessage(obtainMessage(EVENT_CARRIER_CONFIG_CHANGED));
             }
         }
@@ -1039,6 +1046,12 @@ public class GsmCdmaPhone extends Phone {
                 ringingCallState.isAlive());
     }
 
+    /* Validate the given extras if the call is for CS domain or not */
+    protected boolean shallDialOnCircuitSwitch(Bundle extras) {
+        return (extras != null && extras.getInt(QtiCallConstants.EXTRA_CALL_DOMAIN,
+                QtiCallConstants.DOMAIN_AUTOMATIC) == QtiCallConstants.DOMAIN_CS);
+    }
+
     @Override
     public Connection dial(String dialString, @NonNull DialArgs dialArgs)
             throws CallStateException {
@@ -1046,7 +1059,7 @@ public class GsmCdmaPhone extends Phone {
             throw new CallStateException("Sending UUS information NOT supported in CDMA!");
         }
 
-        boolean isEmergency = PhoneNumberUtils.isEmergencyNumber(getSubId(), dialString);
+        boolean isEmergency = isEmergencyNumber(dialString);
         Phone imsPhone = mImsPhone;
 
         CarrierConfigManager configManager =
@@ -1058,7 +1071,8 @@ public class GsmCdmaPhone extends Phone {
                  && imsPhone != null
                  && (imsPhone.isVolteEnabled() || imsPhone.isWifiCallingEnabled() ||
                  (imsPhone.isVideoEnabled() && VideoProfile.isVideo(dialArgs.videoState)))
-                 && (imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE);
+                 && (imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE)
+                 && !shallDialOnCircuitSwitch(dialArgs.intentExtras);
 
         boolean useImsForEmergency = imsPhone != null
                 && isEmergency
@@ -1118,7 +1132,8 @@ public class GsmCdmaPhone extends Phone {
         // Check non-emergency voice CS call - shouldn't dial when POWER_OFF
         if (mSST != null && mSST.mSS.getState() == ServiceState.STATE_POWER_OFF /* CS POWER_OFF */
                 && !VideoProfile.isVideo(dialArgs.videoState) /* voice call */
-                && !isEmergency /* non-emergency call */) {
+                && !isEmergency /* non-emergency call */
+                && !(isUt && useImsForUt) /* not UT */) {
             throw new CallStateException(
                 CallStateException.ERROR_POWER_OFF,
                 "cannot dial voice call in airplane mode");
@@ -1167,7 +1182,7 @@ public class GsmCdmaPhone extends Phone {
         }
 
         Phone imsPhone = mImsPhone;
-        boolean isEmergency = PhoneNumberUtils.isEmergencyNumber(getSubId(), dialString);
+        boolean isEmergency = isEmergencyNumber(dialString);
         boolean shouldConfirmCall =
                         // Using IMS
                         isImsUseEnabled()
@@ -1350,6 +1365,27 @@ public class GsmCdmaPhone extends Phone {
     }
 
     @Override
+    public void addParticipant(String dialString) throws CallStateException {
+        Phone imsPhone = mImsPhone;
+        boolean imsUseEnabled = isImsUseEnabled()
+                 && imsPhone != null
+                 && (imsPhone.isVolteEnabled() || imsPhone.isWifiCallingEnabled() ||
+                 imsPhone.isVideoEnabled())
+                 && (imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE);
+
+        if (imsUseEnabled) {
+            try {
+                logd("addParticipant :: Trying to add participant in IMS call");
+                imsPhone.addParticipant(dialString);
+            } catch (CallStateException e) {
+                loge("addParticipant :: IMS PS call exception " + e);
+            }
+        } else {
+            loge("addParticipant :: IMS is disabled so unable to add participant with IMS call");
+        }
+    }
+
+    @Override
     public void setRadioPower(boolean power) {
         mSST.setRadioPower(power);
     }
@@ -1448,15 +1484,14 @@ public class GsmCdmaPhone extends Phone {
 
     @Override
     public String getDeviceId() {
-        if (isPhoneTypeGsm()) {
-            return mImei;
-        } else {
-            CarrierConfigManager configManager = (CarrierConfigManager)
-                    mContext.getSystemService(Context.CARRIER_CONFIG_SERVICE);
-            boolean force_imei = configManager.getConfigForSubId(getSubId())
-                    .getBoolean(CarrierConfigManager.KEY_FORCE_IMEI_BOOL);
-            if (force_imei) return mImei;
+        CarrierConfigManager configManager = (CarrierConfigManager)
+                mContext.getSystemService(Context.CARRIER_CONFIG_SERVICE);
+        boolean force_imei = configManager.getConfigForSubId(getSubId())
+                .getBoolean(CarrierConfigManager.KEY_FORCE_IMEI_BOOL);
 
+        if (isPhoneTypeGsm() || force_imei) {
+            return getImei();
+        } else {
             String id = getMeid();
             if ((id == null) || id.matches("^0*$")) {
                 loge("getDeviceId(): MEID is not initialized use ESN");
@@ -1483,6 +1518,14 @@ public class GsmCdmaPhone extends Phone {
 
     @Override
     public String getImei() {
+        CarrierConfigManager configManager = (CarrierConfigManager)
+                mContext.getSystemService(Context.CARRIER_CONFIG_SERVICE);
+        boolean enable14DigitImei = configManager.getConfigForSubId(getSubId())
+                .getBoolean("config_enable_display_14digit_imei");
+        if (enable14DigitImei && !TextUtils.isEmpty(mImei)
+                && mImei.length() > IMEI_14_DIGIT) {
+            return mImei.substring(0, IMEI_14_DIGIT);
+        }
         return mImei;
     }
 
@@ -1732,14 +1775,28 @@ public class GsmCdmaPhone extends Phone {
         return (action == CF_ACTION_ENABLE) || (action == CF_ACTION_REGISTRATION);
     }
 
+    private boolean isImsUtEnabledOverCdma() {
+        return isPhoneTypeCdmaLte()
+            && mImsPhone != null
+            && mImsPhone.isUtEnabled();
+    }
+
     @Override
     public void getCallForwardingOption(int commandInterfaceCFReason, Message onComplete) {
-        if (isPhoneTypeGsm()) {
+        getCallForwardingOption(commandInterfaceCFReason,
+            CommandsInterface.SERVICE_CLASS_NONE, onComplete);
+    }
+
+    @Override
+    public void getCallForwardingOption(int commandInterfaceCFReason,
+            int commandInterfaceServiceClass, Message onComplete) {
+        if (isPhoneTypeGsm() || isImsUtEnabledOverCdma()) {
             Phone imsPhone = mImsPhone;
             if ((imsPhone != null)
                     && ((imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE)
                     || imsPhone.isUtEnabled())) {
-                imsPhone.getCallForwardingOption(commandInterfaceCFReason, onComplete);
+                imsPhone.getCallForwardingOption(commandInterfaceCFReason,
+                            commandInterfaceServiceClass, onComplete);
                 return;
             }
 
@@ -1752,10 +1809,10 @@ public class GsmCdmaPhone extends Phone {
                     resp = onComplete;
                 }
                 mCi.queryCallForwardStatus(commandInterfaceCFReason,
-                        CommandsInterface.SERVICE_CLASS_VOICE, null, resp);
+                        commandInterfaceServiceClass, null, resp);
             }
         } else {
-            loge("getCallForwardingOption: not possible in CDMA");
+            loge("getCallForwardingOption: not possible in CDMA without IMS");
         }
     }
 
@@ -1765,13 +1822,28 @@ public class GsmCdmaPhone extends Phone {
             String dialingNumber,
             int timerSeconds,
             Message onComplete) {
-        if (isPhoneTypeGsm()) {
+        setCallForwardingOption(commandInterfaceCFAction,
+                commandInterfaceCFReason, dialingNumber,
+                CommandsInterface.SERVICE_CLASS_VOICE,
+                timerSeconds, onComplete);
+    }
+
+
+    @Override
+    public void setCallForwardingOption(int commandInterfaceCFAction,
+            int commandInterfaceCFReason,
+            String dialingNumber,
+            int commandInterfaceServiceClass,
+            int timerSeconds,
+            Message onComplete) {
+        if (isPhoneTypeGsm() || isImsUtEnabledOverCdma()) {
             Phone imsPhone = mImsPhone;
             if ((imsPhone != null)
                     && ((imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE)
                     || imsPhone.isUtEnabled())) {
                 imsPhone.setCallForwardingOption(commandInterfaceCFAction,
-                        commandInterfaceCFReason, dialingNumber, timerSeconds, onComplete);
+                        commandInterfaceCFReason, dialingNumber,
+                        commandInterfaceServiceClass, timerSeconds, onComplete);
                 return;
             }
 
@@ -1788,13 +1860,13 @@ public class GsmCdmaPhone extends Phone {
                 }
                 mCi.setCallForward(commandInterfaceCFAction,
                         commandInterfaceCFReason,
-                        CommandsInterface.SERVICE_CLASS_VOICE,
+                        commandInterfaceServiceClass,
                         dialingNumber,
                         timerSeconds,
                         resp);
             }
         } else {
-            loge("setCallForwardingOption: not possible in CDMA");
+            loge("setCallForwardingOption: not possible in CDMA without IMS");
         }
     }
 
@@ -1803,9 +1875,7 @@ public class GsmCdmaPhone extends Phone {
             int serviceClass) {
         if (isPhoneTypeGsm()) {
             Phone imsPhone = mImsPhone;
-            if ((imsPhone != null)
-                    && ((imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE)
-                    || imsPhone.isUtEnabled())) {
+            if ((imsPhone != null) && imsPhone.isUtEnabled()) {
                 imsPhone.getCallBarring(facility, password, onComplete, serviceClass);
                 return;
             }
@@ -1820,9 +1890,7 @@ public class GsmCdmaPhone extends Phone {
             Message onComplete, int serviceClass) {
         if (isPhoneTypeGsm()) {
             Phone imsPhone = mImsPhone;
-            if ((imsPhone != null)
-                    && ((imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE)
-                    || imsPhone.isUtEnabled())) {
+            if ((imsPhone != null) && imsPhone.isUtEnabled()) {
                 imsPhone.setCallBarring(facility, lockState, password, onComplete, serviceClass);
                 return;
             }
@@ -1887,7 +1955,7 @@ public class GsmCdmaPhone extends Phone {
 
     @Override
     public void getCallWaiting(Message onComplete) {
-        if (isPhoneTypeGsm()) {
+        if (isPhoneTypeGsm() || isImsUtEnabledOverCdma()) {
             Phone imsPhone = mImsPhone;
             if ((imsPhone != null)
                     && ((imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE)
@@ -1906,7 +1974,7 @@ public class GsmCdmaPhone extends Phone {
 
     @Override
     public void setCallWaiting(boolean enable, Message onComplete) {
-        if (isPhoneTypeGsm()) {
+        if (isPhoneTypeGsm() || isImsUtEnabledOverCdma()) {
             Phone imsPhone = mImsPhone;
             if ((imsPhone != null)
                     && ((imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE)
@@ -1917,7 +1985,7 @@ public class GsmCdmaPhone extends Phone {
 
             mCi.setCallWaiting(enable, CommandsInterface.SERVICE_CLASS_VOICE, onComplete);
         } else {
-            loge("method setCallWaiting is NOT supported in CDMA!");
+            loge("method setCallWaiting is NOT supported in CDMA without IMS!");
         }
     }
 
@@ -2324,10 +2392,10 @@ public class GsmCdmaPhone extends Phone {
                 // Force update IMS service if it is available, if it isn't the config will be
                 // updated when ImsPhoneCallTracker opens a connection.
                 ImsManager imsManager = ImsManager.getInstance(mContext, mPhoneId);
-                if (imsManager.isServiceAvailable()) {
+                if (imsManager.isServiceAvailable() && getIccRecordsLoaded()) {
                     imsManager.updateImsServiceConfig(true);
                 } else {
-                    logd("ImsManager is not available to update CarrierConfig.");
+                    logd("ImsManager/IccRecords Loaded are not available to update CarrierConfig.");
                 }
 
                 // Update broadcastEmergencyCallStateChanges
@@ -2416,6 +2484,7 @@ public class GsmCdmaPhone extends Phone {
                         && !imsiFromSIM.equals(imsi)) {
                     storeVoiceMailNumber(null);
                     setVmSimImsi(null);
+                    setVideoCallForwardingPreference(false);
                 }
 
                 mSimRecordsLoadedRegistrants.notifyRegistrants();
@@ -2659,10 +2728,16 @@ public class GsmCdmaPhone extends Phone {
                 logd("mIccRecords = " + mIccRecords);
                 registerForIccRecordEvents();
                 mIccPhoneBookIntManager.updateIccRecords(mIccRecords.get());
+                updateDataConnectionTracker();
             }
         }
     }
 
+    @Override
+    public SIMRecords getSIMRecords() {
+        return mSimRecords;
+    }
+
     private void processIccRecordEvents(int eventCode) {
         switch (eventCode) {
             case IccRecords.EVENT_CFI:
diff --git a/src/java/com/android/internal/telephony/IccSmsInterfaceManager.java b/src/java/com/android/internal/telephony/IccSmsInterfaceManager.java
index f2383f5..a76f3a5 100644
--- a/src/java/com/android/internal/telephony/IccSmsInterfaceManager.java
+++ b/src/java/com/android/internal/telephony/IccSmsInterfaceManager.java
@@ -48,6 +48,8 @@ import com.android.internal.telephony.gsm.SmsBroadcastConfigInfo;
 import com.android.internal.telephony.uicc.IccConstants;
 import com.android.internal.telephony.uicc.IccFileHandler;
 import com.android.internal.telephony.uicc.IccUtils;
+import com.android.internal.telephony.uicc.UiccController;
+import com.android.internal.telephony.uicc.IccRecords;
 import com.android.internal.util.HexDump;
 
 import java.util.ArrayList;
@@ -1335,4 +1337,17 @@ public class IccSmsInterfaceManager {
         return result != null ? result : destAddr;
     }
 
+    public int getSmsCapacityOnIcc() {
+        int numberOnIcc = -1;
+        IccRecords ir = mPhone.getIccRecords();
+
+        if (ir != null) {
+            numberOnIcc = ir.getSmsCapacityOnIcc();
+        } else {
+            log("getSmsCapacityOnIcc - aborting, no icc card present.");
+        }
+
+        log("getSmsCapacityOnIcc().numberOnIcc = " + numberOnIcc);
+        return numberOnIcc;
+    }
 }
diff --git a/src/java/com/android/internal/telephony/ImsSmsDispatcher.java b/src/java/com/android/internal/telephony/ImsSmsDispatcher.java
index 79ea8d2..e148906 100644
--- a/src/java/com/android/internal/telephony/ImsSmsDispatcher.java
+++ b/src/java/com/android/internal/telephony/ImsSmsDispatcher.java
@@ -16,8 +16,13 @@
 
 package com.android.internal.telephony;
 
+import static android.telephony.SmsManager.RESULT_ERROR_GENERIC_FAILURE;
+import android.content.Context;
+import android.os.Message;
+import android.os.PersistableBundle;
 import android.os.RemoteException;
 import android.provider.Telephony.Sms.Intents;
+import android.telephony.CarrierConfigManager;
 import android.telephony.Rlog;
 import android.telephony.ims.ImsReasonInfo;
 import android.telephony.ims.aidl.IImsSmsListener;
@@ -26,6 +31,8 @@ import android.telephony.ims.feature.MmTelFeature;
 import android.telephony.ims.stub.ImsRegistrationImplBase;
 import android.telephony.ims.stub.ImsSmsImplBase;
 import android.telephony.ims.stub.ImsSmsImplBase.SendStatusResult;
+import android.telephony.PhoneNumberUtils;
+import android.telephony.ServiceState;
 import android.util.Pair;
 
 import com.android.ims.ImsException;
@@ -121,12 +128,19 @@ public class ImsSmsDispatcher extends SMSDispatcher {
                     mTrackers.remove(token);
                     break;
                 case ImsSmsImplBase.SEND_STATUS_ERROR_RETRY:
-                    tracker.mRetryCount += 1;
-                    sendSms(tracker);
-                    break;
                 case ImsSmsImplBase.SEND_STATUS_ERROR_FALLBACK:
-                    fallbackToPstn(token, tracker);
-                    break;
+                    if (tracker.mRetryCount < MAX_SEND_RETRIES) {
+                        tracker.mRetryCount += 1;
+                        if(status == ImsSmsImplBase.SEND_STATUS_ERROR_FALLBACK) {
+                            tracker.mIsFallBackRetry = true;
+                        }
+                        Message retryMsg = obtainMessage(EVENT_SEND_RETRY, tracker);
+                        sendMessageDelayed(retryMsg, SEND_RETRY_DELAY);
+                    } else {
+                        Rlog.e(TAG,"onSendSmsResult Max retrys reaached: " + tracker.mRetryCount);
+                        tracker.onFailed(mContext, RESULT_ERROR_GENERIC_FAILURE, 0);
+                        mTrackers.remove(token);
+                    }
                 default:
             }
         }
@@ -228,6 +242,50 @@ public class ImsSmsDispatcher extends SMSDispatcher {
         getImsManager().onSmsReady();
     }
 
+    private boolean isLteService() {
+        return ((mPhone.getServiceState().getRilDataRadioTechnology() ==
+            ServiceState.RIL_RADIO_TECHNOLOGY_LTE) && (mPhone.getServiceState().
+                getDataRegState() == ServiceState.STATE_IN_SERVICE));
+    }
+
+    private boolean isLimitedLteService() {
+        return ((mPhone.getServiceState().getRilVoiceRadioTechnology() ==
+            ServiceState.RIL_RADIO_TECHNOLOGY_LTE) && mPhone.getServiceState().isEmergencyOnly());
+    }
+
+    private boolean isEmergencySmsPossible() {
+        return isLteService() || isLimitedLteService();
+    }
+
+    public boolean isEmergencySmsSupport(String destAddr) {
+        PersistableBundle b;
+        boolean eSmsCarrierSupport = false;
+        if (!PhoneNumberUtils.isLocalEmergencyNumber(mContext, destAddr)) {
+            Rlog.e(TAG, "Emergency Sms is not supported for: " + destAddr);
+            return false;
+        }
+        CarrierConfigManager configManager = (CarrierConfigManager) mPhone.getContext()
+                .getSystemService(Context.CARRIER_CONFIG_SERVICE);
+        if (configManager == null) {
+            Rlog.e(TAG, "configManager is null");
+            return false;
+        }
+        b = configManager.getConfigForSubId(getSubId());
+        if (b == null) {
+            Rlog.e(TAG, "PersistableBundle is null");
+            return false;
+        }
+        eSmsCarrierSupport = b.getBoolean(CarrierConfigManager.
+                                                      KEY_EMERGENCY_SMS_SUPPORT_BOOL);
+        boolean lteOrLimitedLte = isEmergencySmsPossible();
+        Rlog.i(TAG, "isEmergencySmsSupport emergencySmsCarrierSupport: "
+               + eSmsCarrierSupport + " destAddr: " + destAddr + " mIsImsServiceUp: "
+               + mIsImsServiceUp + " lteOrLimitedLte: " + lteOrLimitedLte);
+
+        return eSmsCarrierSupport && mIsImsServiceUp && lteOrLimitedLte;
+    }
+
+
     public boolean isAvailable() {
         synchronized (mLock) {
             Rlog.d(TAG, "isAvailable: up=" + mIsImsServiceUp + ", reg= " + mIsRegistered
diff --git a/src/java/com/android/internal/telephony/InboundSmsHandler.java b/src/java/com/android/internal/telephony/InboundSmsHandler.java
index 195259a..f8a7388 100644
--- a/src/java/com/android/internal/telephony/InboundSmsHandler.java
+++ b/src/java/com/android/internal/telephony/InboundSmsHandler.java
@@ -758,7 +758,7 @@ public abstract class InboundSmsHandler extends StateMachine {
         byte[][] pdus;
         int destPort = tracker.getDestPort();
         boolean block = false;
-
+        String address = tracker.getAddress();
         // Do not process when the message count is invalid.
         if (messageCount <= 0) {
             loge("processMessagePart: returning false due to invalid message count "
@@ -775,7 +775,6 @@ public abstract class InboundSmsHandler extends StateMachine {
             Cursor cursor = null;
             try {
                 // used by several query selection arguments
-                String address = tracker.getAddress();
                 String refNumber = Integer.toString(tracker.getReferenceNumber());
                 String count = Integer.toString(tracker.getMessageCount());
 
@@ -880,7 +879,8 @@ public abstract class InboundSmsHandler extends StateMachine {
                 }
                 output.write(pdu, 0, pdu.length);
             }
-            int result = mWapPush.dispatchWapPdu(output.toByteArray(), resultReceiver, this);
+            int result = mWapPush.dispatchWapPdu(output.toByteArray(), resultReceiver,
+                    this, address);
             if (DBG) log("dispatchWapPdu() returned " + result);
             // result is Activity.RESULT_OK if an ordered broadcast was sent
             if (result == Activity.RESULT_OK) {
diff --git a/src/java/com/android/internal/telephony/MccTable.java b/src/java/com/android/internal/telephony/MccTable.java
index a010618..79823a1 100644
--- a/src/java/com/android/internal/telephony/MccTable.java
+++ b/src/java/com/android/internal/telephony/MccTable.java
@@ -23,6 +23,7 @@ import android.net.wifi.WifiManager;
 import android.os.Build;
 import android.os.RemoteException;
 import android.os.SystemProperties;
+import android.telephony.SubscriptionManager;
 import android.telephony.TelephonyManager;
 import android.text.TextUtils;
 import android.util.Slog;
@@ -396,6 +397,12 @@ public final class MccTable {
         return locale;
     }
 
+    private static boolean isInvalidOperatorNumeric(String operatorNumeric) {
+        return operatorNumeric == null
+                || operatorNumeric.length() < 5
+                || operatorNumeric.startsWith("000");
+    }
+
     /**
      * Set the country code for wifi.  This sets allowed wifi channels based on the
      * country of the carrier we see.  If we can't see any, reset to 0 so we don't
@@ -404,6 +411,30 @@ public final class MccTable {
      * @param mcc Mobile Country Code of the operator.  0 if not known
      */
     private static void setWifiCountryCodeFromMcc(Context context, int mcc) {
+        final SubscriptionManager subscriptionManager = SubscriptionManager.from(context);
+        final TelephonyManager tm = TelephonyManager.from(context);
+        Slog.d(LOG_TAG, "setWifiCountryCodeFromMcc mcc = " + mcc);
+        int[] subIds = subscriptionManager.getActiveSubscriptionIdList();
+        int phoneId = 0;
+        boolean isValidOnAnySub = false;
+        // Prior to update the "no country" status to wifi service if it is invalid,
+        // Check If any SUB already has valid operator numeric. If it is
+        // found ignore the current SUB's empty or invalid operator numeric.
+        if (mcc == 0 && subIds != null && subIds.length > 0) {
+            for (int subId : subIds) {
+                phoneId = SubscriptionController.getInstance().getPhoneId(subId);
+                String operatorNumeric = tm.getNetworkOperatorForPhone(phoneId);
+                if (!isInvalidOperatorNumeric(operatorNumeric)) {
+                    Slog.d(LOG_TAG, "operatornumeric is valid, "
+                            + "Do not overwrite");
+                    isValidOnAnySub = true;
+                    break;
+                }
+            }
+            if (isValidOnAnySub) {
+                return;
+            }
+        }
         String country = MccTable.countryCodeForMcc(mcc);
         Slog.d(LOG_TAG, "WIFI_COUNTRY_CODE set to " + country);
         WifiManager wM = (WifiManager) context.getSystemService(Context.WIFI_SERVICE);
diff --git a/src/java/com/android/internal/telephony/Phone.java b/src/java/com/android/internal/telephony/Phone.java
index 5943412..629df10 100755
--- a/src/java/com/android/internal/telephony/Phone.java
+++ b/src/java/com/android/internal/telephony/Phone.java
@@ -47,6 +47,7 @@ import android.telephony.CellInfoCdma;
 import android.telephony.CellLocation;
 import android.telephony.ClientRequestStats;
 import android.telephony.ImsiEncryptionInfo;
+import android.telephony.PhoneNumberUtils;
 import android.telephony.PhoneStateListener;
 import android.telephony.PhysicalChannelConfig;
 import android.telephony.RadioAccessFamily;
@@ -71,6 +72,7 @@ import com.android.internal.telephony.uicc.IccCardApplicationStatus.AppType;
 import com.android.internal.telephony.uicc.IccFileHandler;
 import com.android.internal.telephony.uicc.IccRecords;
 import com.android.internal.telephony.uicc.IsimRecords;
+import com.android.internal.telephony.uicc.SIMRecords;
 import com.android.internal.telephony.uicc.UiccCard;
 import com.android.internal.telephony.uicc.UiccCardApplication;
 import com.android.internal.telephony.uicc.UiccController;
@@ -216,6 +218,9 @@ public abstract class Phone extends Handler implements PhoneInternalInterface {
     // Key used to read/write the ID for storing the voice mail
     private static final String VM_ID = "vm_id_key";
 
+    // Key used to read/write if Video Call Forwarding is enabled
+    public static final String CF_VIDEO = "cf_key_video";
+
     // Key used for storing call forwarding status
     public static final String CF_STATUS = "cf_status_key";
     // Key used to read/write the ID for storing the call forwarding status
@@ -1847,7 +1852,31 @@ public abstract class Phone extends Handler implements PhoneInternalInterface {
         Rlog.v(LOG_TAG, "getCallForwardingIndicator: iccForwardingFlag=" + (r != null
                     ? r.getVoiceCallForwardingFlag() : "null") + ", sharedPrefFlag="
                     + getCallForwardingIndicatorFromSharedPref());
-        return (callForwardingIndicator == IccRecords.CALL_FORWARDING_STATUS_ENABLED);
+        return ((callForwardingIndicator == IccRecords.CALL_FORWARDING_STATUS_ENABLED) ||
+                getVideoCallForwardingPreference());
+    }
+
+    /**
+     * This method stores the CF_VIDEO flag in preferences
+     * @param enabled
+     */
+    public void setVideoCallForwardingPreference(boolean enabled) {
+        Rlog.d(LOG_TAG, "Set video call forwarding info to preferences enabled = " + enabled
+                + "subId = " + getSubId());
+        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(mContext);
+        SharedPreferences.Editor edit = sp.edit();
+        edit.putBoolean(CF_VIDEO + getSubId(), enabled);
+        edit.commit();
+    }
+
+    /**
+     * This method gets Video Call Forwarding enabled/disabled from preferences
+     */
+    public boolean getVideoCallForwardingPreference() {
+        Rlog.d(LOG_TAG, "Get video call forwarding info from preferences");
+
+        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(mContext);
+        return sp.getBoolean(CF_VIDEO + getSubId(), false);
     }
 
     public CarrierSignalAgent getCarrierSignalAgent() {
@@ -2413,6 +2442,23 @@ public abstract class Phone extends Handler implements PhoneInternalInterface {
     }
 
     /**
+     * Initiate to add a participant in an IMS call.
+     * This happens asynchronously, so you cannot assume the audio path is
+     * connected (or a call index has been assigned) until PhoneStateChanged
+     * notification has occurred.
+     *
+     * @exception CallStateException if a new outgoing call is not currently
+     *                possible because no more call slots exist or a call exists
+     *                that is dialing, alerting, ringing, or waiting. Other
+     *                errors are handled asynchronously.
+     */
+    public void addParticipant(String dialString) throws CallStateException {
+        // To be overridden by GsmCdmaPhone and ImsPhone.
+        throw new CallStateException("addParticipant :: No-Op base implementation. "
+                + this);
+    }
+
+    /**
      * send burst DTMF tone, it can send the string as single character or multiple character
      * ignore if there is no active call or not valid digits string.
      * Valid digit means only includes characters ISO-LATIN characters 0-9, *, #
@@ -3648,6 +3694,10 @@ public abstract class Phone extends Handler implements PhoneInternalInterface {
         mCi.setSimCardPower(state, null);
     }
 
+    public SIMRecords getSIMRecords() {
+        return null;
+    }
+
     public void setRadioIndicationUpdateMode(int filters, int mode) {
         if (mDeviceStateMonitor != null) {
             mDeviceStateMonitor.setIndicationUpdateMode(filters, mode);
@@ -3658,6 +3708,17 @@ public abstract class Phone extends Handler implements PhoneInternalInterface {
             String gid2, String pnn, String spn) {
     }
 
+    @Override
+    public void getCallForwardingOption(int commandInterfaceCFReason,
+            int commandInterfaceServiceClass, Message onComplete) {
+    }
+
+    @Override
+    public void setCallForwardingOption(int commandInterfaceCFReason,
+            int commandInterfaceCFAction, String dialingNumber,
+            int commandInterfaceServiceClass, int timerSeconds, Message onComplete) {
+    }
+
     public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
         pw.println("Phone: subId=" + getSubId());
         pw.println(" mPhoneId=" + mPhoneId);
@@ -3790,6 +3851,7 @@ public abstract class Phone extends Handler implements PhoneInternalInterface {
             pw.println("++++++++++++++++++++++++++++++++");
         }
     }
+	
     /** @hide */
     /** @hide */
     public void setFactoryModeModemGPIO (int status, int num, Message response) {
@@ -3828,4 +3890,9 @@ public abstract class Phone extends Handler implements PhoneInternalInterface {
     }
 
  //zhouhanxin@oneplus.cn 2016-10-18 for sim managerment end
+ 
+    public boolean isEmergencyNumber(String address) {
+        return PhoneNumberUtils.isEmergencyNumber(getSubId(), address);
+    }
+	
 }
diff --git a/src/java/com/android/internal/telephony/PhoneInternalInterface.java b/src/java/com/android/internal/telephony/PhoneInternalInterface.java
index 123914e..c1be20e 100644
--- a/src/java/com/android/internal/telephony/PhoneInternalInterface.java
+++ b/src/java/com/android/internal/telephony/PhoneInternalInterface.java
@@ -657,6 +657,49 @@ public interface PhoneInternalInterface {
     void getOutgoingCallerIdDisplay(Message onComplete);
 
     /**
+     * getCallForwardingOption
+     * gets a call forwarding option. The return value of
+     * ((AsyncResult)onComplete.obj) is an array of CallForwardInfo.
+     *
+     * @param commandInterfaceCFReason is one of the valid call forwarding
+     *        CF_REASONS, as defined in
+     *        <code>com.android.internal.telephony.CommandsInterface.</code>
+     * @param commandInterfaceServiceClass is one of the valid supplementary
+     *        service class SERVICE_CLASS_* as defined in
+     *        <code>com.android.internal.telephony.CommandsInterface.</code>
+     * @param onComplete a callback message when the action is completed.
+     *        @see com.android.internal.telephony.CallForwardInfo for details.
+     */
+    void getCallForwardingOption(int commandInterfaceCFReason,
+                                 int commandInterfaceServiceClass,
+                                 Message onComplete);
+
+    /**
+     * setCallForwardingOption
+     * sets a call forwarding option.
+     *
+     * @param commandInterfaceCFReason is one of the valid call forwarding
+     *        CF_REASONS, as defined in
+     *        <code>com.android.internal.telephony.CommandsInterface.</code>
+     * @param commandInterfaceCFAction is one of the valid call forwarding
+     *        CF_ACTIONS, as defined in
+     *        <code>com.android.internal.telephony.CommandsInterface.</code>
+     * @param dialingNumber is the target phone number to forward calls to
+     * @param commandInterfaceServiceClass is one of the valid supplementary
+     *        service class SERVICE_CLASS_* as defined in
+     *        <code>com.android.internal.telephony.CommandsInterface.</code>
+     * @param timerSeconds is used by CFNRy to indicate the timeout before
+     *        forwarding is attempted
+     * @param onComplete a callback message when the action is completed.
+     */
+    void setCallForwardingOption(int commandInterfaceCFReason,
+                                 int commandInterfaceCFAction,
+                                 String dialingNumber,
+                                 int commandInterfaceServiceClass,
+                                 int timerSeconds,
+                                 Message onComplete);
+
+    /**
      * setOutgoingCallerIdDisplay
      * sets a call forwarding option.
      *
diff --git a/src/java/com/android/internal/telephony/ProxyController.java b/src/java/com/android/internal/telephony/ProxyController.java
index 95758d7..af39fca 100755
--- a/src/java/com/android/internal/telephony/ProxyController.java
+++ b/src/java/com/android/internal/telephony/ProxyController.java
@@ -473,7 +473,7 @@ public class ProxyController {
      */
     void onFinishRadioCapabilityResponse(Message msg) {
         RadioCapability rc = (RadioCapability) ((AsyncResult) msg.obj).result;
-        if ((rc == null) || (rc.getSession() != mRadioCapabilitySessionId)) {
+        if ((rc != null) && (rc.getSession() != mRadioCapabilitySessionId)) {
             logd("onFinishRadioCapabilityResponse: Ignore session=" + mRadioCapabilitySessionId
                     + " rc=" + rc);
             return;
diff --git a/src/java/com/android/internal/telephony/RIL.java b/src/java/com/android/internal/telephony/RIL.java
index 9beb799..20aa55d 100644
--- a/src/java/com/android/internal/telephony/RIL.java
+++ b/src/java/com/android/internal/telephony/RIL.java
@@ -174,6 +174,7 @@ public class RIL extends BaseCommands implements CommandsInterface {
     AtomicBoolean mTestingEmergencyCall = new AtomicBoolean(false);
 
     final Integer mPhoneId;
+    private List<String> mOldRilFeatures;
 
     /* default work source which will blame phone process */
     protected WorkSource mRILDefaultWorkSource;
@@ -182,7 +183,7 @@ public class RIL extends BaseCommands implements CommandsInterface {
     private WorkSource mActiveWakelockWorkSource;
 
     /** Telephony metrics instance for logging metrics event */
-    private TelephonyMetrics mMetrics = TelephonyMetrics.getInstance();
+    protected TelephonyMetrics mMetrics = TelephonyMetrics.getInstance();
 
     protected boolean mIsMobileNetworkSupported;
     RadioResponse mRadioResponse;
@@ -456,6 +457,9 @@ public class RIL extends BaseCommands implements CommandsInterface {
         mPhoneType = RILConstants.NO_PHONE;
         mPhoneId = instanceId;
 
+        final String oldRilFeatures = SystemProperties.get("ro.telephony.ril.config", "");
+        mOldRilFeatures = Arrays.asList(oldRilFeatures.split(","));
+
         ConnectivityManager cm = (ConnectivityManager)context.getSystemService(
                 Context.CONNECTIVITY_SERVICE);
         mIsMobileNetworkSupported = cm.isNetworkSupported(ConnectivityManager.TYPE_MOBILE);
@@ -2509,7 +2513,7 @@ public class RIL extends BaseCommands implements CommandsInterface {
         }
     }
 
-    private void constructCdmaSendSmsRilRequest(CdmaSmsMessage msg, byte[] pdu) {
+    protected void constructCdmaSendSmsRilRequest(CdmaSmsMessage msg, byte[] pdu) {
         int addrNbrOfDigits;
         int subaddrNbrOfDigits;
         int bearerDataLength;
@@ -2548,6 +2552,11 @@ public class RIL extends BaseCommands implements CommandsInterface {
     }
 
     @Override
+    public void sendCdmaSms(byte[] pdu, Message result, boolean expectMore) {
+        sendCdmaSms(pdu, result);
+    }
+
+    @Override
     public void sendCdmaSms(byte[] pdu, Message result) {
         IRadio radioProxy = getRadioProxy(result);
         if (radioProxy != null) {
@@ -2776,7 +2785,7 @@ public class RIL extends BaseCommands implements CommandsInterface {
 
             CdmaSmsWriteArgs args = new CdmaSmsWriteArgs();
             args.status = status;
-            constructCdmaSendSmsRilRequest(args.message, pdu.getBytes());
+            constructCdmaSendSmsRilRequest(args.message, IccUtils.hexStringToBytes(pdu));
 
             try {
                 radioProxy.writeSmsToRuim(rr.mSerial, args);
@@ -3321,8 +3330,7 @@ public class RIL extends BaseCommands implements CommandsInterface {
     }
 
     @Override
-    public void setUiccSubscription(int slotId, int appIndex, int subId,
-                                    int subStatus, Message result) {
+    public void setUiccSubscription(int appIndex, boolean activate, Message result) {
         IRadio radioProxy = getRadioProxy(result);
         if (radioProxy != null) {
             RILRequest rr = obtainRequest(RIL_REQUEST_SET_UICC_SUBSCRIPTION, result,
@@ -3330,15 +3338,14 @@ public class RIL extends BaseCommands implements CommandsInterface {
 
             if (RILJ_LOGD) {
                 riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
-                        + " slot = " + slotId + " appIndex = " + appIndex
-                        + " subId = " + subId + " subStatus = " + subStatus);
+                        + " appIndex: " + appIndex + " activate: " + activate);
             }
 
             SelectUiccSub info = new SelectUiccSub();
-            info.slot = slotId;
+            info.slot = mPhoneId;
             info.appIndex = appIndex;
-            info.subType = subId;
-            info.actStatus = subStatus;
+            info.subType = mPhoneId;
+            info.actStatus = activate ? 1 : 0;
 
             try {
                 radioProxy.setUiccSubscription(rr.mSerial, info);
@@ -5572,4 +5579,8 @@ public class RIL extends BaseCommands implements CommandsInterface {
                 signalStrength.wcdma.base.signalStrength,
                 signalStrength.wcdma.rscp);
     }
+
+    public boolean needsOldRilFeature(String feature) {
+        return mOldRilFeatures.contains(feature);
+    }
 }
diff --git a/src/java/com/android/internal/telephony/SMSDispatcher.java b/src/java/com/android/internal/telephony/SMSDispatcher.java
index 1e5afc7..74d2ed8 100644
--- a/src/java/com/android/internal/telephony/SMSDispatcher.java
+++ b/src/java/com/android/internal/telephony/SMSDispatcher.java
@@ -50,6 +50,7 @@ import android.os.AsyncResult;
 import android.os.Binder;
 import android.os.Handler;
 import android.os.Message;
+import android.os.PersistableBundle;
 import android.os.Process;
 import android.os.RemoteException;
 import android.os.UserHandle;
@@ -59,6 +60,7 @@ import android.provider.Telephony.Sms;
 import android.service.carrier.CarrierMessagingService;
 import android.service.carrier.ICarrierMessagingCallback;
 import android.service.carrier.ICarrierMessagingService;
+import android.telephony.CarrierConfigManager;
 import android.telephony.CarrierMessagingServiceManager;
 import android.telephony.PhoneNumberUtils;
 import android.telephony.Rlog;
@@ -82,6 +84,7 @@ import com.android.internal.R;
 import com.android.internal.annotations.VisibleForTesting;
 import com.android.internal.telephony.cdma.sms.UserData;
 import com.android.internal.telephony.GsmAlphabet.TextEncodingDetails;
+import com.android.internal.telephony.SmsUsageMonitor.SmsAuthorizationCallback;
 import com.android.internal.telephony.uicc.UiccCard;
 import com.android.internal.telephony.uicc.UiccController;
 
@@ -114,7 +117,7 @@ public abstract class SMSDispatcher extends Handler {
     protected static final int EVENT_SEND_SMS_COMPLETE = 2;
 
     /** Retry sending a previously failed SMS message */
-    private static final int EVENT_SEND_RETRY = 3;
+    protected static final int EVENT_SEND_RETRY = 3;
 
     /** Confirmation required for sending a large number of messages. */
     private static final int EVENT_SEND_LIMIT_REACHED_CONFIRMATION = 4;
@@ -147,9 +150,9 @@ public abstract class SMSDispatcher extends Handler {
     protected final TelephonyManager mTelephonyManager;
 
     /** Maximum number of times to retry sending a failed SMS. */
-    private static final int MAX_SEND_RETRIES = 3;
+    protected static final int MAX_SEND_RETRIES = 3;
     /** Delay before next send attempt on a failed SMS, in milliseconds. */
-    private static final int SEND_RETRY_DELAY = 2000;
+    protected static final int SEND_RETRY_DELAY = 2000;
     /** single part SMS */
     private static final int SINGLE_PART_SMS = 1;
     /** Message sending queue limit */
@@ -1058,7 +1061,9 @@ public abstract class SMSDispatcher extends Handler {
             uData.payloadStr = message;
             uData.userDataHeader = smsHeader;
             if (encoding == SmsConstants.ENCODING_7BIT) {
-                uData.msgEncoding = UserData.ENCODING_GSM_7BIT_ALPHABET;
+                uData.msgEncoding = isAscii7bitSupportedForLongMessage()
+                        ? UserData.ENCODING_7BIT_ASCII : UserData.ENCODING_GSM_7BIT_ALPHABET;
+                Rlog.d(TAG, "Message encoding for proper 7 bit: " + uData.msgEncoding);
             } else { // assume UTF-16
                 uData.msgEncoding = UserData.ENCODING_UNICODE_16;
             }
@@ -1173,7 +1178,23 @@ public abstract class SMSDispatcher extends Handler {
                 return;
             }
 
-            sendSms(tracker);
+            if (mSmsDispatchersController.getUsageMonitor().isSmsAuthorizationEnabled()) {
+                final SmsAuthorizationCallback callback = new SmsAuthorizationCallback() {
+                    @Override
+                    public void onAuthorizationResult(final boolean accepted) {
+                        if (accepted) {
+                            sendSms(tracker);
+                        } else {
+                            tracker.onFailed(mContext, RESULT_ERROR_GENERIC_FAILURE,
+                                    SmsUsageMonitor.ERROR_CODE_BLOCKED);
+                        }
+                    }
+                };
+               mSmsDispatchersController.getUsageMonitor().authorizeOutgoingSms(tracker.mAppInfo,
+                        tracker.mDestAddress,tracker.mFullMessageText, callback, this);
+            } else {
+                sendSms(tracker);
+            }
         }
 
         if (PhoneNumberUtils.isLocalEmergencyNumber(mContext, tracker.mDestAddress)) {
@@ -1461,6 +1482,7 @@ public abstract class SMSDispatcher extends Handler {
         // Tag indicating that this SMS is being handled by the ImsSmsDispatcher. This tracker
         // should not try to use SMS over IMS over the RIL interface in this case when falling back.
         public boolean mUsesImsServiceForIms;
+        public boolean mIsFallBackRetry;
         public int mMessageRef;
         public boolean mExpectMore;
         public int mValidityPeriod;
@@ -1523,6 +1545,7 @@ public abstract class SMSDispatcher extends Handler {
             mUserId = userId;
             mPriority = priority;
             mValidityPeriod = validityPeriod;
+            mIsFallBackRetry = false;
         }
 
         /**
@@ -1962,4 +1985,20 @@ public abstract class SMSDispatcher extends Handler {
     protected boolean isCdmaMo() {
         return mSmsDispatchersController.isCdmaMo();
     }
+
+    private boolean isAscii7bitSupportedForLongMessage() {
+        CarrierConfigManager configManager = (CarrierConfigManager)mContext.getSystemService(
+                Context.CARRIER_CONFIG_SERVICE);
+        PersistableBundle pb = null;
+        final long ident = Binder.clearCallingIdentity();
+        try {
+            pb = configManager.getConfigForSubId(mPhone.getSubId());
+        } finally {
+            Binder.restoreCallingIdentity(ident);
+        }
+        if (pb != null) {
+            return pb.getBoolean("ascii_7_bit_support_for_long_message");
+        }
+        return false;
+    }
 }
diff --git a/src/java/com/android/internal/telephony/ServiceStateTracker.java b/src/java/com/android/internal/telephony/ServiceStateTracker.java
old mode 100644
new mode 100755
index 0502c95..fd292ee
--- a/src/java/com/android/internal/telephony/ServiceStateTracker.java
+++ b/src/java/com/android/internal/telephony/ServiceStateTracker.java
@@ -593,6 +593,7 @@ public class ServiceStateTracker extends Handler {
         }
 
         mSS = new ServiceState();
+        mSS.setStateOutOfService();
         mNewSS = new ServiceState();
         mLastCellInfoListTime = 0;
         mLastCellInfoList = null;
@@ -1529,7 +1530,7 @@ public class ServiceStateTracker extends Handler {
                 getSystemService(Context.TELEPHONY_SERVICE)).
                 getSimOperatorNumericForPhone(mPhone.getPhoneId());
 
-        if (!TextUtils.isEmpty(operatorNumeric) && getCdmaMin() != null) {
+        if (!TextUtils.isEmpty(operatorNumeric) && !TextUtils.isEmpty(getCdmaMin())) {
             return (operatorNumeric + getCdmaMin());
         } else {
             return null;
@@ -1660,9 +1661,9 @@ public class ServiceStateTracker extends Handler {
         mPollingContext[0]--;
 
         if (mPollingContext[0] == 0) {
+            mNewSS.setEmergencyOnly(mEmergencyOnly);
             if (mPhone.isPhoneTypeGsm()) {
                 updateRoamingState();
-                mNewSS.setEmergencyOnly(mEmergencyOnly);
             } else {
                 boolean namMatch = false;
                 if (!isSidsAllZeros() && isHomeSid(mNewSS.getCdmaSystemId())) {
@@ -1804,6 +1805,7 @@ public class ServiceStateTracker extends Handler {
 
                 //Denial reason if registrationState = 3
                 int reasonForDenial = networkRegState.getReasonForDenial();
+                mEmergencyOnly = networkRegState.isEmergencyEnabled();
                 if (mPhone.isPhoneTypeGsm()) {
 
                     mGsmRoaming = regCodeIsRoaming(registrationState);
@@ -1811,7 +1813,6 @@ public class ServiceStateTracker extends Handler {
 
                     boolean isVoiceCapable = mPhone.getContext().getResources()
                             .getBoolean(com.android.internal.R.bool.config_voice_capable);
-                    mEmergencyOnly = networkRegState.isEmergencyEnabled();
                 } else {
                     int roamingIndicator = voiceSpecificStates.roamingIndicator;
 
@@ -2932,6 +2933,12 @@ public class ServiceStateTracker extends Handler {
             }
         }
 
+        if (hasRilVoiceRadioTechnologyChanged || hasRilDataRadioTechnologyChanged) {
+            // Technology has changed, try to fix signal strength type.
+            mSignalStrength.fixType();
+            notifySignalStrength();
+        }
+
         if (hasRegistered) {
             mNetworkAttachedRegistrants.notifyRegistrants();
             mNitzState.handleNetworkAvailable();
@@ -3118,7 +3125,8 @@ public class ServiceStateTracker extends Handler {
             if (!hasBrandOverride && (mCi.getRadioState().isOn()) && (mPhone.isEriFileLoaded()) &&
                     (!ServiceState.isLte(mSS.getRilVoiceRadioTechnology()) ||
                             mPhone.getContext().getResources().getBoolean(com.android.internal.R.
-                                    bool.config_LTE_eri_for_network_name))) {
+                                    bool.config_LTE_eri_for_network_name)) &&
+                                    (!mIsSubscriptionFromRuim)) {
                 // Only when CDMA is in service, ERI will take effect
                 String eriText = mSS.getOperatorAlpha();
                 // Now the Phone sees the new ServiceState so it can get the new ERI text
@@ -4137,7 +4145,7 @@ public class ServiceStateTracker extends Handler {
      * @return true if the signal strength changed and a notification was sent.
      */
     protected boolean onSignalStrengthResult(AsyncResult ar) {
-        boolean isGsm = false;
+        boolean isGsm = mPhone.isPhoneTypeGsm();
         int dataRat = mSS.getRilDataRadioTechnology();
         int voiceRat = mSS.getRilVoiceRadioTechnology();
 
diff --git a/src/java/com/android/internal/telephony/SmsDispatchersController.java b/src/java/com/android/internal/telephony/SmsDispatchersController.java
index f3cd1c7..f058e63 100644
--- a/src/java/com/android/internal/telephony/SmsDispatchersController.java
+++ b/src/java/com/android/internal/telephony/SmsDispatchersController.java
@@ -255,17 +255,26 @@ public class SmsDispatchersController extends Handler {
         String newFormat =
                 (PhoneConstants.PHONE_TYPE_CDMA == mPhone.getPhoneType())
                         ? mCdmaDispatcher.getFormat() : mGsmDispatcher.getFormat();
+        if(mImsSmsDispatcher.isAvailable() && !tracker.mIsFallBackRetry) {
+            newFormat = mImsSmsDispatcher.getFormat();
+        }
 
         // was previously sent sms format match with voice tech?
         if (oldFormat.equals(newFormat)) {
-            if (isCdmaFormat(newFormat)) {
-                Rlog.d(TAG, "old format matched new format (cdma)");
-                mCdmaDispatcher.sendSms(tracker);
+            if (mImsSmsDispatcher.isAvailable() && !tracker.mIsFallBackRetry) {
+                Rlog.d(TAG, "old format matched new format processing over IMS");
+                mImsSmsDispatcher.sendSms(tracker);
                 return;
             } else {
-                Rlog.d(TAG, "old format matched new format (gsm)");
-                mGsmDispatcher.sendSms(tracker);
-                return;
+                if (isCdmaFormat(newFormat)) {
+                    Rlog.d(TAG, "old format matched new format (cdma)");
+                    mCdmaDispatcher.sendSms(tracker);
+                    return;
+                } else {
+                    Rlog.d(TAG, "old format matched new format (gsm)");
+                    mGsmDispatcher.sendSms(tracker);
+                    return;
+                }
             }
         }
 
@@ -322,8 +331,12 @@ public class SmsDispatchersController extends Handler {
         // replace old smsc and pdu with newly encoded ones
         map.put("smsc", pdu.encodedScAddress);
         map.put("pdu", pdu.encodedMessage);
-
-        SMSDispatcher dispatcher = (isCdmaFormat(newFormat)) ? mCdmaDispatcher : mGsmDispatcher;
+        SMSDispatcher dispatcher;
+        if (mImsSmsDispatcher.isAvailable() && !tracker.mIsFallBackRetry) {
+            dispatcher = mImsSmsDispatcher;
+        } else {
+            dispatcher = (isCdmaFormat(newFormat)) ? mCdmaDispatcher : mGsmDispatcher;
+        }
 
         tracker.mFormat = dispatcher.getFormat();
         dispatcher.sendSms(tracker);
@@ -449,7 +462,7 @@ public class SmsDispatchersController extends Handler {
                             PendingIntent sentIntent, PendingIntent deliveryIntent, Uri messageUri,
                             String callingPkg, boolean persistMessage, int priority,
                             boolean expectMore, int validityPeriod) {
-        if (mImsSmsDispatcher.isAvailable()) {
+        if (mImsSmsDispatcher.isAvailable() || mImsSmsDispatcher.isEmergencySmsSupport(destAddr)) {
             mImsSmsDispatcher.sendText(destAddr, scAddr, text, sentIntent, deliveryIntent,
                     messageUri, callingPkg, persistMessage, SMS_MESSAGE_PRIORITY_NOT_SPECIFIED,
                     false /*expectMore*/, SMS_MESSAGE_PERIOD_NOT_SPECIFIED);
diff --git a/src/java/com/android/internal/telephony/SmsUsageMonitor.java b/src/java/com/android/internal/telephony/SmsUsageMonitor.java
index 402a5ef..d39479e 100644
--- a/src/java/com/android/internal/telephony/SmsUsageMonitor.java
+++ b/src/java/com/android/internal/telephony/SmsUsageMonitor.java
@@ -20,6 +20,7 @@ import android.app.AppGlobals;
 import android.content.ContentResolver;
 import android.content.Context;
 import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageInfo;
 import android.content.res.XmlResourceParser;
 import android.database.ContentObserver;
 import android.os.Binder;
@@ -90,6 +91,9 @@ public class SmsUsageMonitor {
     /** Return value from {@link #checkDestination} for premium short codes. */
     static final int CATEGORY_PREMIUM_SHORT_CODE = 4;
 
+    /** Error code for SmsManager sent PendingIntent **/
+    static final int ERROR_CODE_BLOCKED = 191286;
+
     /** @hide */
     public static int mergeShortCodeCategories(int type1, int type2) {
         if (type1 > type2) return type1;
@@ -579,6 +583,23 @@ public class SmsUsageMonitor {
         }).start();
     }
 
+    public interface SmsAuthorizationCallback {
+        void onAuthorizationResult(boolean authorized);
+    }
+
+    public void authorizeOutgoingSms(final PackageInfo packageInfo,
+            final String destinationAddress,
+            final String message,
+            final SmsAuthorizationCallback callback,
+            final Handler callbackHandler) {
+        callback.onAuthorizationResult(true); // Default implementation always authorizes
+    }
+
+    public boolean isSmsAuthorizationEnabled() {
+        return mContext.getResources().getBoolean(
+                com.android.internal.R.bool.config_sms_authorization_enabled);
+    }
+
     private static void checkCallerIsSystemOrPhoneOrSameApp(String pkg) {
         int uid = Binder.getCallingUid();
         int appId = UserHandle.getAppId(uid);
diff --git a/src/java/com/android/internal/telephony/SubscriptionController.java b/src/java/com/android/internal/telephony/SubscriptionController.java
index 2437a8d..e493840 100644
--- a/src/java/com/android/internal/telephony/SubscriptionController.java
+++ b/src/java/com/android/internal/telephony/SubscriptionController.java
@@ -233,6 +233,32 @@ public class SubscriptionController extends ISub.Stub {
         if (DBG) logdl("[SubscriptionController] init by Phone");
     }
 
+    /**
+     * Make sure the caller can read phone state which requires holding the
+     * READ_PHONE_STATE permission and the OP_READ_PHONE_STATE app op being
+     * set to MODE_ALLOWED.
+     *
+     * @param callingPackage The package claiming to make the IPC.
+     * @param message The name of the access protected method.
+     *
+     * @throws SecurityException if the caller does not have READ_PHONE_STATE permission.
+     */
+    private boolean canReadPhoneState(String callingPackage, String message) {
+        try {
+            mContext.enforceCallingOrSelfPermission(
+                    android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE, message);
+
+            // SKIP checking run-time permission since self or using PRIVILEDGED permission
+            return true;
+        } catch (SecurityException e) {
+            mContext.enforceCallingOrSelfPermission(android.Manifest.permission.READ_PHONE_STATE,
+                    message);
+        }
+
+        return mAppOps.noteOp(AppOpsManager.OP_READ_PHONE_STATE, Binder.getCallingUid(),
+                callingPackage) == AppOpsManager.MODE_ALLOWED;
+    }
+
     protected void enforceModifyPhoneState(String message) {
         mContext.enforceCallingOrSelfPermission(
                 android.Manifest.permission.MODIFY_PHONE_STATE, message);
@@ -2205,35 +2231,45 @@ public class SubscriptionController extends ISub.Stub {
      */
     @VisibleForTesting(visibility = VisibleForTesting.Visibility.PRIVATE)
     public void migrateImsSettings() {
-        migrateImsSettingHelper(
-                Settings.Global.ENHANCED_4G_MODE_ENABLED,
-                SubscriptionManager.ENHANCED_4G_MODE_ENABLED);
-        migrateImsSettingHelper(
-                Settings.Global.VT_IMS_ENABLED,
-                SubscriptionManager.VT_IMS_ENABLED);
-        migrateImsSettingHelper(
-                Settings.Global.WFC_IMS_ENABLED,
-                SubscriptionManager.WFC_IMS_ENABLED);
-        migrateImsSettingHelper(
-                Settings.Global.WFC_IMS_MODE,
-                SubscriptionManager.WFC_IMS_MODE);
-        migrateImsSettingHelper(
-                Settings.Global.WFC_IMS_ROAMING_MODE,
-                SubscriptionManager.WFC_IMS_ROAMING_MODE);
-        migrateImsSettingHelper(
-                Settings.Global.WFC_IMS_ROAMING_ENABLED,
-                SubscriptionManager.WFC_IMS_ROAMING_ENABLED);
-    }
-
-    private void migrateImsSettingHelper(String settingGlobal, String subscriptionProperty) {
+        SubscriptionManager sm = SubscriptionManager.from(mContext);
+        if (sm != null) {
+            List<SubscriptionInfo> subInfoList = sm.getAllSubscriptionInfoList();
+            for (SubscriptionInfo si : subInfoList) {
+                int subId = si.getSubscriptionId();
+                if (subId == SubscriptionManager.INVALID_SUBSCRIPTION_ID) {
+                    continue;
+                }
+                migrateImsSettingHelper(
+                        Settings.Global.ENHANCED_4G_MODE_ENABLED + subId,
+                        SubscriptionManager.ENHANCED_4G_MODE_ENABLED, subId);
+                migrateImsSettingHelper(
+                        Settings.Global.VT_IMS_ENABLED + subId,
+                        SubscriptionManager.VT_IMS_ENABLED, subId);
+                migrateImsSettingHelper(
+                        Settings.Global.WFC_IMS_ENABLED + subId,
+                        SubscriptionManager.WFC_IMS_ENABLED, subId);
+                migrateImsSettingHelper(
+                        Settings.Global.WFC_IMS_MODE + subId,
+                        SubscriptionManager.WFC_IMS_MODE, subId);
+                migrateImsSettingHelper(
+                        Settings.Global.WFC_IMS_ROAMING_MODE + subId,
+                        SubscriptionManager.WFC_IMS_ROAMING_MODE, subId);
+                migrateImsSettingHelper(
+                        Settings.Global.WFC_IMS_ROAMING_ENABLED + subId,
+                        SubscriptionManager.WFC_IMS_ROAMING_ENABLED, subId);
+            }
+        }
+    }
+
+    private void migrateImsSettingHelper(String settingGlobal, String subscriptionProperty,
+                int subId) {
         ContentResolver resolver = mContext.getContentResolver();
-        int defaultSubId = getDefaultVoiceSubId();
         try {
             int prevSetting = Settings.Global.getInt(resolver, settingGlobal);
 
             if (prevSetting != DEPRECATED_SETTING) {
                 // Write previous setting into Subscription DB.
-                setSubscriptionPropertyIntoContentResolver(defaultSubId, subscriptionProperty,
+                setSubscriptionPropertyIntoContentResolver(subId, subscriptionProperty,
                         Integer.toString(prevSetting), resolver);
                 // Write global setting value with DEPRECATED_SETTING making sure
                 // migration only happen once.
diff --git a/src/java/com/android/internal/telephony/SubscriptionInfoUpdater.java b/src/java/com/android/internal/telephony/SubscriptionInfoUpdater.java
index 4a40a9a..f58ed53 100644
--- a/src/java/com/android/internal/telephony/SubscriptionInfoUpdater.java
+++ b/src/java/com/android/internal/telephony/SubscriptionInfoUpdater.java
@@ -113,6 +113,7 @@ public class SubscriptionInfoUpdater extends Handler {
     private static int[] mInsertSimState = new int[PROJECT_SIM_NUM];
     private static int[] sSimCardState = new int[PROJECT_SIM_NUM];
     private static int[] sSimApplicationState = new int[PROJECT_SIM_NUM];
+    private boolean[] mIsRecordLoaded = new boolean[PROJECT_SIM_NUM];
     private SubscriptionManager mSubscriptionManager = null;
     private EuiccManager mEuiccManager;
     private IPackageManager mPackageManager;
@@ -141,6 +142,10 @@ public class SubscriptionInfoUpdater extends Handler {
 
         mCarrierServiceBindHelper = new CarrierServiceBindHelper(mContext);
         initializeCarrierApps();
+
+        for (int index = 0; index < PROJECT_SIM_NUM; index++) {
+            mIsRecordLoaded[index] = false;
+        }
     }
 
     public SubscriptionInfoUpdater(Context context, Phone[] phone, CommandsInterface[] ci) {
@@ -383,6 +388,7 @@ public class SubscriptionInfoUpdater extends Handler {
             return;
         }
         mIccId[slotId] = IccUtils.stripTrailingFs(records.getFullIccId());
+        mIsRecordLoaded[slotId] = true;
 
         if (isAllIccIdQueryDone()) {
             updateSubscriptionInfoByIccId();
@@ -445,6 +451,7 @@ public class SubscriptionInfoUpdater extends Handler {
                             Rlog.e(LOG_TAG, "Settings Exception Reading Value At Index for "
                                     + "Settings.Global.PREFERRED_NETWORK_MODE");
                         }
+
                         Settings.Global.putInt(
                                 mPhone[slotId].getContext().getContentResolver(),
                                 Global.PREFERRED_NETWORK_MODE + subId,
@@ -464,18 +471,22 @@ public class SubscriptionInfoUpdater extends Handler {
                     editor.putInt(CURR_SUBID + slotId, subId);
                     editor.apply();
                 }
+
+                // Update set of enabled carrier apps now that the privilege rules may have changed.
+                CarrierAppUtils.disableCarrierAppsUntilPrivileged(mContext.getOpPackageName(),
+                        mPackageManager, TelephonyManager.getDefault(),
+                        mContext.getContentResolver(), mCurrentlyActiveUserId);
+
+                if (mIsRecordLoaded[slotId] == true) {
+                    broadcastSimStateChanged(slotId, IccCardConstants.
+                            INTENT_VALUE_ICC_LOADED, null);
+                    broadcastSimCardStateChanged(slotId, TelephonyManager.SIM_STATE_PRESENT);
+                    broadcastSimApplicationStateChanged(slotId, TelephonyManager.SIM_STATE_LOADED);
+                    updateCarrierServices(slotId, IccCardConstants.INTENT_VALUE_ICC_LOADED);
+                    mIsRecordLoaded[slotId] = false;
+                }
             }
         }
-
-        // Update set of enabled carrier apps now that the privilege rules may have changed.
-        CarrierAppUtils.disableCarrierAppsUntilPrivileged(mContext.getOpPackageName(),
-                mPackageManager, TelephonyManager.getDefault(),
-                mContext.getContentResolver(), mCurrentlyActiveUserId);
-
-        broadcastSimStateChanged(loadedSlotId, IccCardConstants.INTENT_VALUE_ICC_LOADED, null);
-        broadcastSimCardStateChanged(loadedSlotId, TelephonyManager.SIM_STATE_PRESENT);
-        broadcastSimApplicationStateChanged(loadedSlotId, TelephonyManager.SIM_STATE_LOADED);
-        updateCarrierServices(loadedSlotId, IccCardConstants.INTENT_VALUE_ICC_LOADED);
     }
 
     private void updateCarrierServices(int slotId, String simState) {
diff --git a/src/java/com/android/internal/telephony/SubscriptionMonitor.java b/src/java/com/android/internal/telephony/SubscriptionMonitor.java
index 8ccec6f..b489fb4 100644
--- a/src/java/com/android/internal/telephony/SubscriptionMonitor.java
+++ b/src/java/com/android/internal/telephony/SubscriptionMonitor.java
@@ -69,12 +69,6 @@ public class SubscriptionMonitor {
 
     public SubscriptionMonitor(ITelephonyRegistry tr, Context context,
             SubscriptionController subscriptionController, int numPhones) {
-        try {
-            tr.addOnSubscriptionsChangedListener(context.getOpPackageName(),
-                    mSubscriptionsChangedListener);
-        } catch (RemoteException e) {
-        }
-
         mSubscriptionController = subscriptionController;
         mContext = context;
 
@@ -90,6 +84,11 @@ public class SubscriptionMonitor {
             mDefaultDataSubChangedRegistrants[phoneId] = new RegistrantList();
             mPhoneSubId[phoneId] = mSubscriptionController.getSubIdUsingPhoneId(phoneId);
         }
+        try {
+            tr.addOnSubscriptionsChangedListener(context.getOpPackageName(),
+                    mSubscriptionsChangedListener);
+        } catch (RemoteException e) {
+        }
 
         mContext.registerReceiver(mDefaultDataSubscriptionChangedReceiver,
                 new IntentFilter(TelephonyIntents.ACTION_DEFAULT_DATA_SUBSCRIPTION_CHANGED));
diff --git a/src/java/com/android/internal/telephony/TelephonyComponentFactory.java b/src/java/com/android/internal/telephony/TelephonyComponentFactory.java
old mode 100644
new mode 100755
index 485d36d..3a8481e
--- a/src/java/com/android/internal/telephony/TelephonyComponentFactory.java
+++ b/src/java/com/android/internal/telephony/TelephonyComponentFactory.java
@@ -22,6 +22,7 @@ import android.os.Handler;
 import android.os.IDeviceIdleController;
 import android.os.Looper;
 import android.os.ServiceManager;
+import android.telephony.Rlog;
 import android.telephony.AccessNetworkConstants.TransportType;
 import android.telephony.Rlog;
 
diff --git a/src/java/com/android/internal/telephony/UiccSmsController.java b/src/java/com/android/internal/telephony/UiccSmsController.java
index 59449b8..e43ecc5 100644
--- a/src/java/com/android/internal/telephony/UiccSmsController.java
+++ b/src/java/com/android/internal/telephony/UiccSmsController.java
@@ -39,7 +39,7 @@ import java.util.List;
  * UiccSmsController to provide an inter-process communication to
  * access Sms in Icc.
  */
-public class UiccSmsController extends ISms.Stub {
+public class UiccSmsController extends ISmsBaseImpl {
     static final String LOG_TAG = "RIL_UiccSmsController";
 
     protected UiccSmsController() {
@@ -99,7 +99,7 @@ public class UiccSmsController extends ISms.Stub {
     @Override
     public void sendDataForSubscriber(int subId, String callingPackage, String destAddr,
             String scAddr, int destPort, byte[] data, PendingIntent sentIntent,
-            PendingIntent deliveryIntent) {
+            PendingIntent deliveryIntent) throws android.os.RemoteException {
         IccSmsInterfaceManager iccSmsIntMgr = getIccSmsInterfaceManager(subId);
         if (iccSmsIntMgr != null) {
             iccSmsIntMgr.sendData(callingPackage, destAddr, scAddr, destPort, data,
@@ -126,7 +126,8 @@ public class UiccSmsController extends ISms.Stub {
     }
 
     public void sendText(String callingPackage, String destAddr, String scAddr,
-            String text, PendingIntent sentIntent, PendingIntent deliveryIntent) {
+            String text, PendingIntent sentIntent, PendingIntent deliveryIntent) 
+            throws android.os.RemoteException {
         sendTextForSubscriber(getPreferredSmsSubscription(), callingPackage, destAddr, scAddr,
             text, sentIntent, deliveryIntent, true /* persistMessageForNonDefaultSmsApp*/);
     }
@@ -134,7 +135,7 @@ public class UiccSmsController extends ISms.Stub {
     @Override
     public void sendTextForSubscriber(int subId, String callingPackage, String destAddr,
             String scAddr, String text, PendingIntent sentIntent, PendingIntent deliveryIntent,
-            boolean persistMessageForNonDefaultSmsApp) {
+            boolean persistMessageForNonDefaultSmsApp) throws android.os.RemoteException {
         IccSmsInterfaceManager iccSmsIntMgr = getIccSmsInterfaceManager(subId);
         if (iccSmsIntMgr != null) {
             iccSmsIntMgr.sendText(callingPackage, destAddr, scAddr, text, sentIntent,
@@ -163,7 +164,7 @@ public class UiccSmsController extends ISms.Stub {
     public void sendTextForSubscriberWithOptions(int subId, String callingPackage,
             String destAddr, String scAddr, String parts, PendingIntent sentIntents,
             PendingIntent deliveryIntents, boolean persistMessage, int priority,
-            boolean expectMore, int validityPeriod) {
+            boolean expectMore, int validityPeriod) throws android.os.RemoteException {
         IccSmsInterfaceManager iccSmsIntMgr = getIccSmsInterfaceManager(subId);
         if (iccSmsIntMgr != null ) {
             iccSmsIntMgr.sendTextWithOptions(callingPackage, destAddr, scAddr, parts, sentIntents,
@@ -202,7 +203,7 @@ public class UiccSmsController extends ISms.Stub {
     public void sendMultipartTextForSubscriberWithOptions(int subId, String callingPackage,
             String destAddr, String scAddr, List<String> parts, List<PendingIntent> sentIntents,
             List<PendingIntent> deliveryIntents, boolean persistMessage, int priority,
-            boolean expectMore, int validityPeriod) {
+            boolean expectMore, int validityPeriod) throws android.os.RemoteException {
         IccSmsInterfaceManager iccSmsIntMgr = getIccSmsInterfaceManager(subId);
         if (iccSmsIntMgr != null ) {
             iccSmsIntMgr.sendMultipartTextWithOptions(callingPackage, destAddr, scAddr, parts,
@@ -255,12 +256,13 @@ public class UiccSmsController extends ISms.Stub {
     }
 
     @Override
-    public int getPremiumSmsPermission(String packageName) {
+    public int getPremiumSmsPermission(String packageName) throws android.os.RemoteException {
         return getPremiumSmsPermissionForSubscriber(getPreferredSmsSubscription(), packageName);
     }
 
     @Override
-    public int getPremiumSmsPermissionForSubscriber(int subId, String packageName) {
+    public int getPremiumSmsPermissionForSubscriber(int subId, String packageName)
+            throws android.os.RemoteException {
         IccSmsInterfaceManager iccSmsIntMgr = getIccSmsInterfaceManager(subId);
         if (iccSmsIntMgr != null ) {
             return iccSmsIntMgr.getPremiumSmsPermission(packageName);
@@ -272,12 +274,14 @@ public class UiccSmsController extends ISms.Stub {
     }
 
     @Override
-    public void setPremiumSmsPermission(String packageName, int permission) {
+    public void setPremiumSmsPermission(String packageName, int permission)
+            throws android.os.RemoteException {
          setPremiumSmsPermissionForSubscriber(getPreferredSmsSubscription(), packageName, permission);
     }
 
     @Override
-    public void setPremiumSmsPermissionForSubscriber(int subId, String packageName, int permission) {
+    public void setPremiumSmsPermissionForSubscriber(int subId, String packageName, int permission)
+            throws android.os.RemoteException {
         IccSmsInterfaceManager iccSmsIntMgr = getIccSmsInterfaceManager(subId);
         if (iccSmsIntMgr != null ) {
             iccSmsIntMgr.setPremiumSmsPermission(packageName, permission);
@@ -287,7 +291,7 @@ public class UiccSmsController extends ISms.Stub {
     }
 
     @Override
-    public boolean isImsSmsSupportedForSubscriber(int subId) {
+    public boolean isImsSmsSupportedForSubscriber(int subId) throws android.os.RemoteException {
         IccSmsInterfaceManager iccSmsIntMgr = getIccSmsInterfaceManager(subId);
         if (iccSmsIntMgr != null ) {
             return iccSmsIntMgr.isImsSmsSupported();
@@ -298,7 +302,7 @@ public class UiccSmsController extends ISms.Stub {
     }
 
     @Override
-    public boolean isSmsSimPickActivityNeeded(int subId) {
+    public boolean isSmsSimPickActivityNeeded(int subId) throws android.os.RemoteException {
         final Context context = ActivityThread.currentApplication().getApplicationContext();
         TelephonyManager telephonyManager =
                 (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
@@ -331,7 +335,7 @@ public class UiccSmsController extends ISms.Stub {
     }
 
     @Override
-    public String getImsSmsFormatForSubscriber(int subId) {
+    public String getImsSmsFormatForSubscriber(int subId) throws android.os.RemoteException {
         IccSmsInterfaceManager iccSmsIntMgr = getIccSmsInterfaceManager(subId);
         if (iccSmsIntMgr != null ) {
             return iccSmsIntMgr.getImsSmsFormat();
@@ -343,7 +347,8 @@ public class UiccSmsController extends ISms.Stub {
 
     @Override
     public void injectSmsPduForSubscriber(
-            int subId, byte[] pdu, String format, PendingIntent receivedIntent) {
+            int subId, byte[] pdu, String format, PendingIntent receivedIntent)
+            throws android.os.RemoteException{
         IccSmsInterfaceManager iccSmsIntMgr = getIccSmsInterfaceManager(subId);
         if (iccSmsIntMgr != null) {
             iccSmsIntMgr.injectSmsPdu(pdu, format, receivedIntent);
@@ -367,7 +372,7 @@ public class UiccSmsController extends ISms.Stub {
      * @return User preferred SMS subscription
      */
     @Override
-    public int getPreferredSmsSubscription() {
+    public int getPreferredSmsSubscription() throws android.os.RemoteException {
         return SubscriptionController.getInstance().getDefaultSmsSubId();
     }
 
@@ -376,7 +381,7 @@ public class UiccSmsController extends ISms.Stub {
      * @return True if SMS prompt is enabled.
      */
     @Override
-    public boolean isSMSPromptEnabled() {
+    public boolean isSMSPromptEnabled() throws android.os.RemoteException {
         return PhoneFactory.isSMSPromptEnabled();
     }
 
@@ -409,7 +414,8 @@ public class UiccSmsController extends ISms.Stub {
     }
 
     @Override
-    public String createAppSpecificSmsToken(int subId, String callingPkg, PendingIntent intent) {
+    public String createAppSpecificSmsToken(int subId, String callingPkg, PendingIntent intent)
+            throws android.os.RemoteException {
         return getPhone(subId).getAppSmsManager().createAppSpecificSmsToken(callingPkg, intent);
     }
 
@@ -427,4 +433,20 @@ public class UiccSmsController extends ISms.Stub {
             sendErrorInPendingIntent(intent, errorCode);
         }
     }
+
+    /**
+     * Get the capacity count of sms on Icc card.
+     **/
+    @Override
+    public int getSmsCapacityOnIccForSubscriber(int subId)
+            throws android.os.RemoteException {
+       IccSmsInterfaceManager iccSmsIntMgr = getIccSmsInterfaceManager(subId);
+
+        if (iccSmsIntMgr != null ) {
+            return iccSmsIntMgr.getSmsCapacityOnIcc();
+        } else {
+            Rlog.e(LOG_TAG, "iccSmsIntMgr is null for " + " subId: " + subId);
+            return -1;
+        }
+    }
 }
diff --git a/src/java/com/android/internal/telephony/WapPushOverSms.java b/src/java/com/android/internal/telephony/WapPushOverSms.java
index f4c0103..eff5c67 100755
--- a/src/java/com/android/internal/telephony/WapPushOverSms.java
+++ b/src/java/com/android/internal/telephony/WapPushOverSms.java
@@ -46,6 +46,7 @@ import android.provider.Telephony.Sms.Intents;
 import android.telephony.Rlog;
 import android.telephony.SmsManager;
 import android.telephony.SubscriptionManager;
+import android.text.TextUtils;
 import android.util.Log;
 
 import com.android.internal.telephony.uicc.IccUtils;
@@ -325,6 +326,21 @@ public class WapPushOverSms implements ServiceConnection {
      *         to applications
      */
     public int dispatchWapPdu(byte[] pdu, BroadcastReceiver receiver, InboundSmsHandler handler) {
+        return dispatchWapPdu(pdu, receiver, handler, null);
+    }
+
+    /**
+     * Dispatches inbound messages that are in the WAP PDU format. See
+     * wap-230-wsp-20010705-a section 8 for details on the WAP PDU format.
+     *
+     * @param pdu The WAP PDU, made up of one or more SMS PDUs
+     * @param address The originating address
+     * @return a result code from {@link android.provider.Telephony.Sms.Intents}, or
+     *         {@link Activity#RESULT_OK} if the message has been broadcast
+     *         to applications
+     */
+    public int dispatchWapPdu(byte[] pdu, BroadcastReceiver receiver, InboundSmsHandler handler,
+            String address) {
         DecodedResult result = decodeWapPdu(pdu, handler);
         if (result.statusCode != Activity.RESULT_OK) {
             return result.statusCode;
@@ -360,6 +376,9 @@ public class WapPushOverSms implements ServiceConnection {
                     intent.putExtra("data", result.intentData);
                     intent.putExtra("contentTypeParameters", result.contentTypeParameters);
                     SubscriptionManager.putPhoneIdAndSubIdExtra(intent, result.phoneId);
+                    if (!TextUtils.isEmpty(address)) {
+                        intent.putExtra("address", address);
+                    }
 
                     int procRet = wapPushMan.processMessage(
                         result.wapAppId, result.contentType, intent);
@@ -391,6 +410,9 @@ public class WapPushOverSms implements ServiceConnection {
         intent.putExtra("data", result.intentData);
         intent.putExtra("contentTypeParameters", result.contentTypeParameters);
         SubscriptionManager.putPhoneIdAndSubIdExtra(intent, result.phoneId);
+        if (!TextUtils.isEmpty(address)) {
+            intent.putExtra("address", address);
+        }
 
         // Direct the intent to only the default MMS app. If we can't find a default MMS app
         // then sent it to all broadcast receivers.
diff --git a/src/java/com/android/internal/telephony/cat/AppInterface.java b/src/java/com/android/internal/telephony/cat/AppInterface.java
index 1f2d3a0..6d7250e 100755
--- a/src/java/com/android/internal/telephony/cat/AppInterface.java
+++ b/src/java/com/android/internal/telephony/cat/AppInterface.java
@@ -39,6 +39,7 @@ public interface AppInterface {
     //This is used to send ALPHA string from card to STK App.
     public static final String ALPHA_STRING = "alpha_string";
 
+    public static final String AID = "aid";
     // This is used to send refresh-result when MSG_ID_ICC_REFRESH is received.
     public static final String REFRESH_RESULT = "refresh_result";
     //This is used to send card status from card to STK App.
@@ -78,6 +79,7 @@ public interface AppInterface {
         SEND_SS(0x11),
         SEND_USSD(0x12),
         SEND_SMS(0x13),
+        RUN_AT(0x34),
         SEND_DTMF(0x14),
         SET_UP_EVENT_LIST(0x05),
         SET_UP_IDLE_MODE_TEXT(0x28),
diff --git a/src/java/com/android/internal/telephony/cat/CatCmdMessage.java b/src/java/com/android/internal/telephony/cat/CatCmdMessage.java
index 62d8869..77c25bf 100644
--- a/src/java/com/android/internal/telephony/cat/CatCmdMessage.java
+++ b/src/java/com/android/internal/telephony/cat/CatCmdMessage.java
@@ -36,6 +36,11 @@ public class CatCmdMessage implements Parcelable {
     private SetupEventListSettings mSetupEventListSettings = null;
     private boolean mLoadIconFailed = false;
 
+    // Command Qualifier values for refresh command
+    static final int REFRESH_NAA_INIT_AND_FULL_FILE_CHANGE  = 0x00;
+    static final int REFRESH_NAA_INIT_AND_FILE_CHANGE       = 0x02;
+    static final int REFRESH_NAA_INIT                       = 0x03;
+    static final int REFRESH_UICC_RESET                     = 0x04;
     /*
      * Container for Launch Browser command settings.
      */
@@ -82,6 +87,8 @@ public class CatCmdMessage implements Parcelable {
         case SET_UP_IDLE_MODE_TEXT:
         case SEND_DTMF:
         case SEND_SMS:
+        case RUN_AT:
+        case REFRESH:
         case SEND_SS:
         case SEND_USSD:
             mTextMsg = ((DisplayTextParams) cmdParams).mTextMsg;
@@ -121,7 +128,6 @@ public class CatCmdMessage implements Parcelable {
             mSetupEventListSettings.eventList = ((SetEventListParams) cmdParams).mEventInfo;
             break;
         case PROVIDE_LOCAL_INFORMATION:
-        case REFRESH:
         default:
             break;
         }
@@ -244,4 +250,15 @@ public class CatCmdMessage implements Parcelable {
     public boolean hasIconLoadFailed() {
         return mLoadIconFailed;
     }
+
+    public boolean isRefreshResetOrInit() {
+        if ((mCmdDet.commandQualifier == REFRESH_NAA_INIT_AND_FULL_FILE_CHANGE)
+            || (mCmdDet.commandQualifier == REFRESH_NAA_INIT_AND_FILE_CHANGE )
+            || (mCmdDet.commandQualifier == REFRESH_NAA_INIT)
+            || (mCmdDet.commandQualifier == REFRESH_UICC_RESET)) {
+            return true;
+        } else {
+            return false;
+        }
+    }
 }
diff --git a/src/java/com/android/internal/telephony/cat/CatService.java b/src/java/com/android/internal/telephony/cat/CatService.java
index e5f4b90..f0f6e9b 100644
--- a/src/java/com/android/internal/telephony/cat/CatService.java
+++ b/src/java/com/android/internal/telephony/cat/CatService.java
@@ -396,9 +396,8 @@ public class CatService extends Handler implements AppInterface {
             case DISPLAY_TEXT:
                 break;
             case REFRESH:
-                // ME side only handles refresh commands which meant to remove IDLE
-                // MODE TEXT.
-                cmdParams.mCmdDet.typeOfCommand = CommandType.SET_UP_IDLE_MODE_TEXT.value();
+                //Stk app service displays alpha id to user if it is present, nothing to do here.
+                CatLog.d(this, "Pass Refresh to Stk app");
                 break;
             case SET_UP_IDLE_MODE_TEXT:
                 resultCode = cmdParams.mLoadIconFailed ? ResultCode.PRFRMD_ICON_NOT_DISPLAYED
@@ -442,6 +441,7 @@ public class CatService extends Handler implements AppInterface {
                 break;
             case SEND_DTMF:
             case SEND_SMS:
+            case RUN_AT:
             case SEND_SS:
             case SEND_USSD:
                 if ((((DisplayTextParams)cmdParams).mTextMsg.text != null)
@@ -532,6 +532,7 @@ public class CatService extends Handler implements AppInterface {
 
     private void broadcastCatCmdIntent(CatCmdMessage cmdMsg) {
         Intent intent = new Intent(AppInterface.CAT_CMD_ACTION);
+        intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
         intent.putExtra("STK CMD", cmdMsg);
         intent.putExtra("SLOT_ID", mSlotId);
         intent.setComponent(AppInterface.getDefaultSTKApplication());
@@ -550,6 +551,7 @@ public class CatService extends Handler implements AppInterface {
         Intent intent = new Intent(AppInterface.CAT_SESSION_END_ACTION);
         intent.putExtra("SLOT_ID", mSlotId);
         intent.setComponent(AppInterface.getDefaultSTKApplication());
+        intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
         mContext.sendBroadcast(intent, AppInterface.STK_PERMISSION);
     }
 
@@ -894,13 +896,15 @@ public class CatService extends Handler implements AppInterface {
     private void  broadcastCardStateAndIccRefreshResp(CardState cardState,
             IccRefreshResponse iccRefreshState) {
         Intent intent = new Intent(AppInterface.CAT_ICC_STATUS_CHANGE);
+        intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
         boolean cardPresent = (cardState == CardState.CARDSTATE_PRESENT);
 
         if (iccRefreshState != null) {
             //This case is when MSG_ID_ICC_REFRESH is received.
             intent.putExtra(AppInterface.REFRESH_RESULT, iccRefreshState.refreshResult);
+            intent.putExtra(AppInterface.AID, iccRefreshState.aid);
             CatLog.d(this, "Sending IccResult with Result: "
-                    + iccRefreshState.refreshResult);
+                    + iccRefreshState.refreshResult + " " + "aid: " + iccRefreshState.aid);
         }
 
         // This sends an intent with CARD_ABSENT (0 - false) /CARD_PRESENT (1 - true).
diff --git a/src/java/com/android/internal/telephony/cat/CommandParamsFactory.java b/src/java/com/android/internal/telephony/cat/CommandParamsFactory.java
index 232f808..4514299 100644
--- a/src/java/com/android/internal/telephony/cat/CommandParamsFactory.java
+++ b/src/java/com/android/internal/telephony/cat/CommandParamsFactory.java
@@ -61,12 +61,6 @@ class CommandParamsFactory extends Handler {
     static final int LOAD_SINGLE_ICON       = 1;
     static final int LOAD_MULTI_ICONS       = 2;
 
-    // Command Qualifier values for refresh command
-    static final int REFRESH_NAA_INIT_AND_FULL_FILE_CHANGE  = 0x00;
-    static final int REFRESH_NAA_INIT_AND_FILE_CHANGE       = 0x02;
-    static final int REFRESH_NAA_INIT                       = 0x03;
-    static final int REFRESH_UICC_RESET                     = 0x04;
-
     // Command Qualifier values for PLI command
     static final int DTTZ_SETTING                           = 0x03;
     static final int LANGUAGE_SETTING                       = 0x04;
@@ -188,6 +182,7 @@ class CommandParamsFactory extends Handler {
                  break;
              case SEND_DTMF:
              case SEND_SMS:
+             case RUN_AT:
              case SEND_SS:
              case SEND_USSD:
                  cmdPending = processEventNotify(cmdDet, ctlvs);
@@ -197,9 +192,8 @@ class CommandParamsFactory extends Handler {
                  cmdPending = processSetupCall(cmdDet, ctlvs);
                  break;
              case REFRESH:
-                processRefresh(cmdDet, ctlvs);
-                cmdPending = false;
-                break;
+                 cmdPending = processEventNotify(cmdDet, ctlvs);
+                 break;
              case LAUNCH_BROWSER:
                  cmdPending = processLaunchBrowser(cmdDet, ctlvs);
                  break;
@@ -585,32 +579,6 @@ class CommandParamsFactory extends Handler {
     }
 
     /**
-     * Processes REFRESH proactive command from the SIM card.
-     *
-     * @param cmdDet Command Details container object.
-     * @param ctlvs List of ComprehensionTlv objects following Command Details
-     *        object and Device Identities object within the proactive command
-     */
-    private boolean processRefresh(CommandDetails cmdDet,
-            List<ComprehensionTlv> ctlvs) {
-
-        CatLog.d(this, "process Refresh");
-
-        // REFRESH proactive command is rerouted by the baseband and handled by
-        // the telephony layer. IDLE TEXT should be removed for a REFRESH command
-        // with "initialization" or "reset"
-        switch (cmdDet.commandQualifier) {
-        case REFRESH_NAA_INIT_AND_FULL_FILE_CHANGE:
-        case REFRESH_NAA_INIT_AND_FILE_CHANGE:
-        case REFRESH_NAA_INIT:
-        case REFRESH_UICC_RESET:
-            mCmdParams = new DisplayTextParams(cmdDet, null);
-            break;
-        }
-        return false;
-    }
-
-    /**
      * Processes SELECT_ITEM proactive command from the SIM card.
      *
      * @param cmdDet Command Details container object.
diff --git a/src/java/com/android/internal/telephony/cdma/CdmaInboundSmsHandler.java b/src/java/com/android/internal/telephony/cdma/CdmaInboundSmsHandler.java
index e2c178a..3149351 100644
--- a/src/java/com/android/internal/telephony/cdma/CdmaInboundSmsHandler.java
+++ b/src/java/com/android/internal/telephony/cdma/CdmaInboundSmsHandler.java
@@ -153,6 +153,10 @@ public class CdmaInboundSmsHandler extends InboundSmsHandler {
                 // handled below, after storage check
                 break;
 
+            case SmsEnvelope.TELESERVICE_CT_WAP:
+                // handled below, after TELESERVICE_WAP
+                break;
+
             default:
                 loge("unsupported teleservice 0x" + Integer.toHexString(teleService));
                 return Intents.RESULT_SMS_UNSUPPORTED;
@@ -170,6 +174,15 @@ public class CdmaInboundSmsHandler extends InboundSmsHandler {
             return processCdmaWapPdu(sms.getUserData(), sms.mMessageRef,
                     sms.getOriginatingAddress(), sms.getDisplayOriginatingAddress(),
                     sms.getTimestampMillis());
+        } else if (SmsEnvelope.TELESERVICE_CT_WAP == teleService) {
+            /*  WDP header contains Message identifier
+               and User data subparametrs extract these fields */
+            if (!sms.processCdmaCTWdpHeader(sms)) {
+                return Intents.RESULT_SMS_HANDLED;
+            }
+            return processCdmaWapPdu(sms.getUserData(), sms.mMessageRef,
+                    sms.getOriginatingAddress(), sms.getDisplayOriginatingAddress(),
+                    sms.getTimestampMillis());
         }
 
         return dispatchNormalMessage(smsb);
diff --git a/src/java/com/android/internal/telephony/cdma/CdmaSMSDispatcher.java b/src/java/com/android/internal/telephony/cdma/CdmaSMSDispatcher.java
old mode 100755
new mode 100644
index bbaa3ca..f1465c5
--- a/src/java/com/android/internal/telephony/cdma/CdmaSMSDispatcher.java
+++ b/src/java/com/android/internal/telephony/cdma/CdmaSMSDispatcher.java
@@ -148,7 +148,7 @@ public class CdmaSMSDispatcher extends SMSDispatcher {
         //   SMS over IMS is being handled by the ImsSmsDispatcher implementation and has indicated
         //   that the message should fall back to sending over CS.
         if (0 == tracker.mImsRetry && !isIms() || imsSmsDisabled || tracker.mUsesImsServiceForIms) {
-            mCi.sendCdmaSms(pdu, reply);
+            mCi.sendCdmaSms(pdu, reply, tracker.mRetryCount == 0 && tracker.mExpectMore);
         } else {
             mCi.sendImsCdmaSms(pdu, tracker.mImsRetry, tracker.mMessageRef, reply);
             // increment it here, so in case of SMS_FAIL_RETRY over IMS
diff --git a/src/java/com/android/internal/telephony/dataconnection/DataConnection.java b/src/java/com/android/internal/telephony/dataconnection/DataConnection.java
index 0696aa9..74609c1 100644
--- a/src/java/com/android/internal/telephony/dataconnection/DataConnection.java
+++ b/src/java/com/android/internal/telephony/dataconnection/DataConnection.java
@@ -20,7 +20,10 @@ import static android.net.NetworkPolicyManager.OVERRIDE_CONGESTED;
 import static android.net.NetworkPolicyManager.OVERRIDE_UNMETERED;
 
 import android.app.PendingIntent;
+import android.content.BroadcastReceiver;
 import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
 import android.net.ConnectivityManager;
 import android.net.ConnectivityManager.PacketKeepalive;
 import android.net.KeepalivePacketData;
@@ -42,6 +45,7 @@ import android.os.SystemProperties;
 import android.telephony.AccessNetworkConstants;
 import android.telephony.Rlog;
 import android.telephony.ServiceState;
+import android.telephony.SubscriptionManager;
 import android.telephony.TelephonyManager;
 import android.telephony.data.DataCallResponse;
 import android.telephony.data.DataProfile;
@@ -100,6 +104,9 @@ public class DataConnection extends StateMachine {
 
     private static final String NETWORK_TYPE = "MOBILE";
 
+    private static final String ACTION_DDS_SWITCH_DONE
+            = "org.codeaurora.intent.action.ACTION_DDS_SWITCH_DONE";
+
     // The data connection controller
     private DcController mDcController;
 
@@ -195,6 +202,8 @@ public class DataConnection extends StateMachine {
     public HashMap<ApnContext, ConnectionParams> mApnContexts = null;
     PendingIntent mReconnectIntent = null;
 
+    private boolean mRegistered = false;
+
 
     // ***** Event codes for driving the state machine, package visible for Dcc
     static final int BASE = Protocol.BASE_DATA_CONNECTION;
@@ -220,9 +229,10 @@ public class DataConnection extends StateMachine {
     static final int EVENT_KEEPALIVE_START_REQUEST = BASE + 21;
     static final int EVENT_KEEPALIVE_STOP_REQUEST = BASE + 22;
     static final int EVENT_LINK_CAPACITY_CHANGED = BASE + 23;
+    static final int EVENT_DATA_CONNECTION_DDS_SWITCHED = BASE + 24;
 
     private static final int CMD_TO_STRING_COUNT =
-            EVENT_LINK_CAPACITY_CHANGED - BASE + 1;
+            EVENT_DATA_CONNECTION_DDS_SWITCHED - BASE + 1;
 
     private static String[] sCmdToString = new String[CMD_TO_STRING_COUNT];
     static {
@@ -253,6 +263,8 @@ public class DataConnection extends StateMachine {
         sCmdToString[EVENT_KEEPALIVE_START_REQUEST - BASE] = "EVENT_KEEPALIVE_START_REQUEST";
         sCmdToString[EVENT_KEEPALIVE_STOP_REQUEST - BASE] = "EVENT_KEEPALIVE_STOP_REQUEST";
         sCmdToString[EVENT_LINK_CAPACITY_CHANGED - BASE] = "EVENT_LINK_CAPACITY_CHANGED";
+        sCmdToString[EVENT_DATA_CONNECTION_DDS_SWITCHED - BASE] =
+                "EVENT_DATA_CONNECTION_DDS_SWITCHED";
     }
     // Convert cmd to string or null if unknown
     static String cmdToString(int cmd) {
@@ -458,6 +470,35 @@ public class DataConnection extends StateMachine {
         }
     }
 
+    private boolean isApnTypeDefault() {
+        for (String type : mApnSetting.types) {
+            if (type.equals(PhoneConstants.APN_TYPE_DEFAULT)) {
+                return true;
+            } else {
+                continue;
+            }
+        }
+        return false;
+    }
+
+    /* Receiver to handle DDS change event */
+    private BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {
+        public void onReceive(Context context, Intent intent) {
+            String action = intent.getAction();
+            log("mBroadcastReceiver - " + action);
+            if (action.equals(ACTION_DDS_SWITCH_DONE)) {
+                int ddsSubId = intent.getIntExtra(PhoneConstants.SUBSCRIPTION_KEY,
+                        SubscriptionManager.INVALID_SUBSCRIPTION_ID);
+                log("got ACTION_DDS_SWITCH_DONE, new DDS = "
+                        + ddsSubId + "update network score");
+                if (mNetworkAgent != null && mPhone.getSubId() != ddsSubId) {
+                    DataConnection.this.sendMessage(DataConnection.this.
+                            obtainMessage(EVENT_DATA_CONNECTION_DDS_SWITCHED));
+                }
+            }
+        }
+    };
+
     //***** Constructor (NOTE: uses dcc.getHandler() as its Handler)
     private DataConnection(Phone phone, String name, int id,
                            DcTracker dct, DataServiceManager dataServiceManager,
@@ -1392,6 +1433,12 @@ public class DataConnection extends StateMachine {
                                 ConnectivityManager.PacketKeepalive.ERROR_INVALID_NETWORK);
                     }
                     break;
+                case EVENT_DATA_CONNECTION_DDS_SWITCHED:
+                    if (mNetworkAgent != null) {
+                        mNetworkAgent.sendNetworkScore(50);
+                    }
+                    break;
+
                 default:
                     if (DBG) {
                         log("DcDefaultState: shouldn't happen but ignore msg.what="
@@ -1726,6 +1773,13 @@ public class DataConnection extends StateMachine {
                     getHandler(), DataConnection.EVENT_KEEPALIVE_STATUS, null);
             mPhone.mCi.registerForLceInfo(
                     getHandler(), DataConnection.EVENT_LINK_CAPACITY_CHANGED, null);
+
+            if (isApnTypeDefault() && !mRegistered) {
+                /* Start listening to the DDS change event. */
+                mPhone.getContext().registerReceiver(mBroadcastReceiver,
+                        new IntentFilter(ACTION_DDS_SWITCH_DONE));
+                mRegistered = true;
+            }
         }
 
         @Override
@@ -1746,6 +1800,10 @@ public class DataConnection extends StateMachine {
                     reason, mNetworkInfo.getExtraInfo());
             mPhone.mCi.unregisterForNattKeepaliveStatus(getHandler());
             mPhone.mCi.unregisterForLceInfo(getHandler());
+            if (mRegistered) {
+                mPhone.getContext().unregisterReceiver(mBroadcastReceiver);
+                mRegistered = false;
+            }
             if (mNetworkAgent != null) {
                 mNetworkAgent.sendNetworkInfo(mNetworkInfo);
                 mNetworkAgent = null;
diff --git a/src/java/com/android/internal/telephony/dataconnection/DataEnabledSettings.java b/src/java/com/android/internal/telephony/dataconnection/DataEnabledSettings.java
index 3b856a7..d5ea7e0 100644
--- a/src/java/com/android/internal/telephony/dataconnection/DataEnabledSettings.java
+++ b/src/java/com/android/internal/telephony/dataconnection/DataEnabledSettings.java
@@ -22,6 +22,7 @@ import android.os.Handler;
 import android.os.RegistrantList;
 import android.os.SystemProperties;
 import android.provider.Settings;
+import android.provider.Settings.SettingNotFoundException;
 import android.telephony.Rlog;
 import android.telephony.SubscriptionManager;
 import android.telephony.TelephonyManager;
@@ -132,6 +133,28 @@ public class DataEnabledSettings {
         }
     }
 
+    /**
+     * Set default value for {@link android.provider.Settings.Global#MOBILE_DATA}
+     */
+    public void setDefaultMobileDataEnabled() {
+        // For single SIM phones, this is a per phone property.
+        String setting = getMobileDataSettingName();
+        boolean useDefaultValue = false;
+        try {
+            Settings.Global.getInt(mResolver, setting);
+        } catch (SettingNotFoundException ex) {
+            //Update to carrier default if uninitialized.
+            useDefaultValue = true;
+        }
+
+        if (useDefaultValue) {
+            boolean defaultVal = "true".equalsIgnoreCase(SystemProperties.get(
+                   "ro.com.android.mobiledata", "true"));
+            log("etDefaultMobileDataEnabled " + setting + "default value: " + defaultVal);
+            Settings.Global.putInt(mResolver, setting, defaultVal ? 1 : 0);
+        }
+    }
+
     public synchronized void setPolicyDataEnabled(boolean enabled) {
         localLog("PolicyDataEnabled", enabled);
         boolean prevDataEnabled = isDataEnabled();
diff --git a/src/java/com/android/internal/telephony/dataconnection/DcTracker.java b/src/java/com/android/internal/telephony/dataconnection/DcTracker.java
index a00fba0..289913a 100644
--- a/src/java/com/android/internal/telephony/dataconnection/DcTracker.java
+++ b/src/java/com/android/internal/telephony/dataconnection/DcTracker.java
@@ -94,6 +94,8 @@ import com.android.internal.telephony.dataconnection.DataConnectionReasons.DataA
 import com.android.internal.telephony.dataconnection.DataConnectionReasons.DataDisallowedReasonType;
 import com.android.internal.telephony.metrics.TelephonyMetrics;
 import com.android.internal.telephony.uicc.IccRecords;
+import com.android.internal.telephony.uicc.RuimRecords;
+import com.android.internal.telephony.uicc.SIMRecords;
 import com.android.internal.telephony.uicc.UiccController;
 import com.android.internal.util.ArrayUtils;
 import com.android.internal.util.AsyncChannel;
@@ -124,6 +126,7 @@ public class DcTracker extends Handler {
     public AtomicBoolean isCleanupRequired = new AtomicBoolean(false);
 
     private final AlarmManager mAlarmManager;
+    private SIMRecords mSimRecords;
 
     /* Currently requested APN type (TODO: This should probably be a parameter not a member) */
     private String mRequestedApnType = PhoneConstants.APN_TYPE_DEFAULT;
@@ -143,6 +146,8 @@ public class DcTracker extends Handler {
     // Default sent packets without ack which triggers initial recovery steps
     private static final int NUMBER_SENT_PACKETS_OF_HANG = 10;
 
+    private static final int EVENT_SIM_RECORDS_LOADED = 100;
+
     // Default for the data stall alarm while non-aggressive stall detection
     private static final int DATA_STALL_ALARM_NON_AGGRESSIVE_DELAY_IN_MS_DEFAULT = 1000 * 60 * 6;
     // Default for the data stall alarm for aggressive stall detection
@@ -251,6 +256,7 @@ public class DcTracker extends Handler {
             } else if (action.equals(CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED)) {
                 if (mIccRecords.get() != null && mIccRecords.get().getRecordsLoaded()) {
                     setDefaultDataRoamingEnabled();
+                    mDataEnabledSettings.setDefaultMobileDataEnabled();
                 }
             } else {
                 if (DBG) log("onReceive: Unknown action=" + action);
@@ -279,29 +285,31 @@ public class DcTracker extends Handler {
     };
 
     private SubscriptionManager mSubscriptionManager;
-    private final OnSubscriptionsChangedListener mOnSubscriptionsChangedListener =
-            new OnSubscriptionsChangedListener() {
-                public final AtomicInteger mPreviousSubId =
-                        new AtomicInteger(SubscriptionManager.INVALID_SUBSCRIPTION_ID);
+    private final DctOnSubscriptionsChangedListener
+            mOnSubscriptionsChangedListener = new DctOnSubscriptionsChangedListener();
 
-                /**
-                 * Callback invoked when there is any change to any SubscriptionInfo. Typically
-                 * this method invokes {@link SubscriptionManager#getActiveSubscriptionInfoList}
-                 */
-                @Override
-                public void onSubscriptionsChanged() {
-                    if (DBG) log("SubscriptionListener.onSubscriptionInfoChanged");
-                    // Set the network type, in case the radio does not restore it.
-                    int subId = mPhone.getSubId();
-                    if (mSubscriptionManager.isActiveSubId(subId)) {
-                        registerSettingsObserver();
-                    }
-                    if (mPreviousSubId.getAndSet(subId) != subId &&
-                            mSubscriptionManager.isActiveSubId(subId)) {
-                        onRecordsLoadedOrSubIdChanged();
-                    }
-                }
-            };
+    private class DctOnSubscriptionsChangedListener extends OnSubscriptionsChangedListener {
+        public final AtomicInteger mPreviousSubId =
+                new AtomicInteger(SubscriptionManager.INVALID_SUBSCRIPTION_ID);
+
+        /**
+         * Callback invoked when there is any change to any SubscriptionInfo. Typically
+         * this method invokes {@link SubscriptionManager#getActiveSubscriptionInfoList}
+         */
+        @Override
+        public void onSubscriptionsChanged() {
+            if (DBG) log("SubscriptionListener.onSubscriptionInfoChanged");
+            // Set the network type, in case the radio does not restore it.
+            int subId = mPhone.getSubId();
+            if (mSubscriptionManager.isActiveSubId(subId)) {
+                registerSettingsObserver();
+            }
+            if (mSubscriptionManager.isActiveSubId(subId) &&
+                    mPreviousSubId.getAndSet(subId) != subId) {
+                onRecordsLoadedOrSubIdChanged();
+            }
+        }
+    };
 
     private final SettingsObserver mSettingsObserver;
 
@@ -357,18 +365,12 @@ public class DcTracker extends Handler {
             return "{txSum=" + txPkts + " rxSum=" + rxPkts + "}";
         }
 
-        /**
-         * Get Tcp Tx/Rx packet count from TrafficStats
-         */
-        public void updateTcpTxRxSum() {
+        public void updateDataStallTxRxSum() {
             this.txPkts = TrafficStats.getMobileTcpTxPackets();
             this.rxPkts = TrafficStats.getMobileTcpRxPackets();
         }
 
-        /**
-         * Get total Tx/Rx packet count from TrafficStats
-         */
-        public void updateTotalTxRxSum() {
+        public void updateDataActivityTxRxSum() {
             this.txPkts = TrafficStats.getMobileTxPackets();
             this.rxPkts = TrafficStats.getMobileRxPackets();
         }
@@ -583,6 +585,10 @@ public class DcTracker extends Handler {
 
     private final int mTransportType;
 
+    /** MMS Data Profile Device Override */
+    private static final int MMS_DATA_PROFILE = SystemProperties.getInt(
+            "ro.telephony.mms_data_profile", RILConstants.DATA_PROFILE_DEFAULT);
+
     public DcTracker(Phone phone) { 
       this(phone, TransportType.WWAN);
     }
@@ -1488,8 +1494,18 @@ public class DcTracker extends Handler {
             apnContext.setConcurrentVoiceAndDataAllowed(mPhone.getServiceStateTracker()
                     .isConcurrentVoiceAndDataAllowed());
             if (apnContext.getState() == DctConstants.State.IDLE) {
+                String requestedApnType = apnContext.getApnType();
+                /*when UICC card is not present, add default emergency apn to apnsettings
+                  only if emergency apn is not present.
+                */
+                if(requestedApnType.equals(PhoneConstants.APN_TYPE_EMERGENCY)){
+                    if(mAllApnSettings == null){
+                        mAllApnSettings = new ArrayList<ApnSetting>();
+                    }
+                    addEmergencyApnSetting();
+                }
                 ArrayList<ApnSetting> waitingApns =
-                        buildWaitingApns(apnContext.getApnType(), radioTech);
+                        buildWaitingApns(requestedApnType, radioTech);
                 if (waitingApns.isEmpty()) {
                     notifyNoData(DcFailCause.MISSING_UNKNOWN_APN, apnContext);
                     notifyOffApnsOfAvailability(apnContext.getReason());
@@ -1581,19 +1597,23 @@ public class DcTracker extends Handler {
             disableMeteredOnly = reason.equals(Phone.REASON_DATA_SPECIFIC_DISABLED) ||
                     reason.equals(Phone.REASON_ROAMING_ON) ||
                     reason.equals(Phone.REASON_CARRIER_ACTION_DISABLE_METERED_APN) ||
+                    reason.equals(Phone.REASON_SINGLE_PDN_ARBITRATION) ||
                     reason.equals(Phone.REASON_PDP_RESET);
         }
 
         for (ApnContext apnContext : mApnContexts.values()) {
             if (disableMeteredOnly) {
-                // Use ApnSetting to decide metered or non-metered.
-                // Tear down all metered data connections.
-                ApnSetting apnSetting = apnContext.getApnSetting();
-                if (apnSetting != null && apnSetting.isMetered(mPhone)) {
-                    if (apnContext.isDisconnected() == false) didDisconnect = true;
-                    if (DBG) log("clean up metered ApnContext Type: " + apnContext.getApnType());
-                    apnContext.setReason(reason);
-                    cleanUpConnection(tearDown, apnContext);
+                if (!apnContext.getApnType().equals(PhoneConstants.APN_TYPE_IMS)) {
+                    // Use ApnSetting to decide metered or non-metered.
+                    // Tear down all metered data connections.
+                    ApnSetting apnSetting = apnContext.getApnSetting();
+                    if (apnSetting != null && apnSetting.isMetered(mPhone)) {
+                            if (apnContext.isDisconnected() == false) didDisconnect = true;
+                            if (DBG) log("clean up metered ApnContext Type: " +
+                                    apnContext.getApnType());
+                            apnContext.setReason(reason);
+                            cleanUpConnection(tearDown, apnContext);
+                    }
                 }
             } else {
                 // Exclude the IMS APN from single DataConenction case.
@@ -2047,8 +2067,8 @@ public class DcTracker extends Handler {
                         // If any call actually requested to be disconnected, means we can't
                         // bring up this connection yet as we need to wait for those data calls
                         // to be disconnected.
-                        if (DBG) log("setupData: Some calls are disconnecting first."
-                                + " Wait and retry");
+                        if (DBG) log("setupData: Some calls are disconnecting first." +
+                                " Wait and retry");
                         return false;
                     }
                 }
@@ -2391,6 +2411,9 @@ public class DcTracker extends Handler {
         mAutoAttachOnCreationConfig = false;
         // Clear auto attach as modem is expected to do a new attach once SIM is ready
         mAutoAttachOnCreation.set(false);
+        // Reset previous SUB ID as the same SIM might be inserted back in hot-swap case
+        mOnSubscriptionsChangedListener.mPreviousSubId.set(
+                SubscriptionManager.INVALID_SUBSCRIPTION_ID);
     }
 
     private void onSetDependencyMet(String apnType, boolean met) {
@@ -3695,6 +3718,17 @@ public class DcTracker extends Handler {
         return null;
     }
 
+    void onRecordsLoaded() {
+        // If onRecordsLoadedOrSubIdChanged() is not called here, it should be called on
+        // onSubscriptionsChanged() when a valid subId is available.
+        int subId = mPhone.getSubId();
+        if (mSubscriptionManager.isActiveSubId(subId)) {
+            onRecordsLoadedOrSubIdChanged();
+        } else {
+            log("Ignoring EVENT_RECORDS_LOADED as subId is not valid: " + subId);
+        }
+    }
+
     @Override
     public void handleMessage (Message msg) {
         if (VDBG) log("handleMessage msg=" + msg);
@@ -3709,6 +3743,20 @@ public class DcTracker extends Handler {
                 } else {
                     log("Ignoring EVENT_RECORDS_LOADED as subId is not valid: " + subId);
                 }
+				mSimRecords = mPhone.getSIMRecords();
+                if ((mIccRecords.get() instanceof RuimRecords) && (mSimRecords != null)) {
+                    mSimRecords.registerForRecordsLoaded(this, EVENT_SIM_RECORDS_LOADED, null);
+                } else {
+                    onRecordsLoaded();
+                }
+                break;
+
+            case EVENT_SIM_RECORDS_LOADED:
+                onRecordsLoaded();
+                if (mSimRecords != null) {
+                    mSimRecords.unregisterForRecordsLoaded(this);
+                    mSimRecords = null;
+                }
                 break;
 
             case DctConstants.EVENT_DATA_CONNECTION_DETACHED:
@@ -4062,6 +4110,8 @@ public class DcTracker extends Handler {
             return RILConstants.DATA_PROFILE_DEFAULT; // DEFAULT for now
         } else if (TextUtils.equals(apnType, PhoneConstants.APN_TYPE_DUN)) {
             return RILConstants.DATA_PROFILE_TETHERED;
+        } else if (TextUtils.equals(apnType, PhoneConstants.APN_TYPE_MMS)) {
+            return MMS_DATA_PROFILE;
         } else {
             return RILConstants.DATA_PROFILE_DEFAULT;
         }
@@ -4541,7 +4591,7 @@ public class DcTracker extends Handler {
 
         TxRxSum preTxRxSum = new TxRxSum(mTxPkts, mRxPkts);
         TxRxSum curTxRxSum = new TxRxSum();
-        curTxRxSum.updateTotalTxRxSum();
+        curTxRxSum.updateDataActivityTxRxSum();
         mTxPkts = curTxRxSum.txPkts;
         mRxPkts = curTxRxSum.rxPkts;
 
@@ -4714,7 +4764,7 @@ public class DcTracker extends Handler {
         long sent, received;
 
         TxRxSum preTxRxSum = new TxRxSum(mDataStallTxRxSum);
-        mDataStallTxRxSum.updateTcpTxRxSum();
+        mDataStallTxRxSum.updateDataStallTxRxSum();
 
         if (VDBG_STALL) {
             log("updateDataStallInfo: mDataStallTxRxSum=" + mDataStallTxRxSum +
diff --git a/src/java/com/android/internal/telephony/dataconnection/TelephonyNetworkFactory.java b/src/java/com/android/internal/telephony/dataconnection/TelephonyNetworkFactory.java
index 114a4b4..b900464 100644
--- a/src/java/com/android/internal/telephony/dataconnection/TelephonyNetworkFactory.java
+++ b/src/java/com/android/internal/telephony/dataconnection/TelephonyNetworkFactory.java
@@ -27,8 +27,10 @@ import android.os.Handler;
 import android.os.Looper;
 import android.os.Message;
 import android.telephony.Rlog;
+import android.telephony.TelephonyManager;
 import android.util.LocalLog;
 
+import com.android.internal.telephony.PhoneFactory;
 import com.android.internal.telephony.PhoneSwitcher;
 import com.android.internal.telephony.SubscriptionController;
 import com.android.internal.telephony.SubscriptionMonitor;
@@ -56,6 +58,7 @@ public class TelephonyNetworkFactory extends NetworkFactory {
     private boolean mIsActive;
     private boolean mIsDefault;
     private int mSubscriptionId;
+    private Context mContext;
 
     private final static int TELEPHONY_NETWORK_SCORE = 50;
 
@@ -66,10 +69,14 @@ public class TelephonyNetworkFactory extends NetworkFactory {
     private static final int EVENT_NETWORK_REQUEST              = 4;
     private static final int EVENT_NETWORK_RELEASE              = 5;
 
+    private static final int PRIMARY_SLOT = 0;
+    private static final int SECONDARY_SLOT = 1;
+
     public TelephonyNetworkFactory(PhoneSwitcher phoneSwitcher,
             SubscriptionController subscriptionController, SubscriptionMonitor subscriptionMonitor,
             Looper looper, Context context, int phoneId, DcTracker dcTracker) {
         super(looper, context, "TelephonyNetworkFactory[" + phoneId + "]", null);
+        mContext = context;
         mInternalHandler = new InternalHandler(looper);
 
         setCapabilityFilter(makeNetworkFilter(subscriptionController, phoneId));
@@ -174,15 +181,13 @@ public class TelephonyNetworkFactory extends NetworkFactory {
     // apply or revoke requests if our active-ness changes
     private void onActivePhoneSwitch() {
         final boolean newIsActive = mPhoneSwitcher.isPhoneActive(mPhoneId);
-        if (mIsActive != newIsActive) {
-            mIsActive = newIsActive;
-            String logString = "onActivePhoneSwitch(" + mIsActive + ", " + mIsDefault + ")";
-            if (DBG) log(logString);
-            if (mIsDefault) {
-                applyRequests(mDefaultRequests, (mIsActive ? REQUEST : RELEASE), logString);
-            }
-            applyRequests(mSpecificRequests, (mIsActive ? REQUEST : RELEASE), logString);
+        mIsActive = newIsActive;
+        String logString = "onActivePhoneSwitch(" + mIsActive + ", " + mIsDefault + ")";
+        if (DBG) log(logString);
+        if (mIsDefault) {
+            applyRequests(mDefaultRequests, (mIsActive ? REQUEST : RELEASE), logString);
         }
+        applyRequests(mSpecificRequests, (mIsActive ? REQUEST : RELEASE), logString);
     }
 
     // watch for phone->subId changes, reapply new filter and let
@@ -207,7 +212,11 @@ public class TelephonyNetworkFactory extends NetworkFactory {
             String logString = "onDefaultChange(" + mIsActive + "," + mIsDefault + ")";
             if (DBG) log(logString);
             if (mIsActive == false) return;
-            applyRequests(mDefaultRequests, (mIsDefault ? REQUEST : RELEASE), logString);
+            if (mSubscriptionController.getActiveSubInfoCount(mContext.getOpPackageName()) == 1) {
+                applyRequests(mDefaultRequests, (mIsDefault ? REQUEST : RELEASE), logString);
+            } else if (!mIsDefault) {
+                applyRequests(mDefaultRequests, RELEASE, logString);
+            }
         }
     }
 
@@ -218,6 +227,15 @@ public class TelephonyNetworkFactory extends NetworkFactory {
         msg.sendToTarget();
     }
 
+    private boolean isNetworkCapabilityEims(NetworkRequest networkRequest) {
+        return networkRequest.networkCapabilities.hasCapability(
+            android.net.NetworkCapabilities.NET_CAPABILITY_EIMS);
+    }
+
+    private boolean isSimPresentInSecondarySlot() {
+        return TelephonyManager.getDefault().hasIccCard(SECONDARY_SLOT);
+    }
+
     private void onNeedNetworkFor(Message msg) {
         NetworkRequest networkRequest = (NetworkRequest)msg.obj;
         boolean isApplicable = false;
@@ -239,7 +257,11 @@ public class TelephonyNetworkFactory extends NetworkFactory {
                 isApplicable = true;
             }
         }
-        if (mIsActive && isApplicable) {
+
+        //Allow EIMS networkrequest on default slot in SIM less case.
+        if ((mIsActive && isApplicable) || (isNetworkCapabilityEims(networkRequest) &&
+                PhoneFactory.getDefaultPhone().getPhoneId() == mPhoneId &&
+                !isSimPresentInSecondarySlot())) {
             String s = "onNeedNetworkFor";
             localLog.log(s);
             log(s + " " + networkRequest);
diff --git a/src/java/com/android/internal/telephony/imsphone/ImsPhone.java b/src/java/com/android/internal/telephony/imsphone/ImsPhone.java
index 3333697..7d473e0 100644
--- a/src/java/com/android/internal/telephony/imsphone/ImsPhone.java
+++ b/src/java/com/android/internal/telephony/imsphone/ImsPhone.java
@@ -34,7 +34,9 @@ import static com.android.internal.telephony.CommandsInterface.CF_REASON_BUSY;
 import static com.android.internal.telephony.CommandsInterface.CF_REASON_NOT_REACHABLE;
 import static com.android.internal.telephony.CommandsInterface.CF_REASON_NO_REPLY;
 import static com.android.internal.telephony.CommandsInterface.CF_REASON_UNCONDITIONAL;
+import static com.android.internal.telephony.CommandsInterface.SERVICE_CLASS_DATA_SYNC;
 import static com.android.internal.telephony.CommandsInterface.SERVICE_CLASS_NONE;
+import static com.android.internal.telephony.CommandsInterface.SERVICE_CLASS_PACKET;
 import static com.android.internal.telephony.CommandsInterface.SERVICE_CLASS_VOICE;
 
 import android.app.Activity;
@@ -46,6 +48,7 @@ import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
 import android.net.NetworkStats;
+import android.content.IntentFilter;
 import android.net.Uri;
 import android.os.AsyncResult;
 import android.os.Bundle;
@@ -69,9 +72,11 @@ import android.telephony.UssdResponse;
 import android.telephony.ims.ImsCallForwardInfo;
 import android.telephony.ims.ImsCallProfile;
 import android.telephony.ims.ImsReasonInfo;
+import android.telephony.ims.ImsStreamMediaProfile;
 import android.telephony.ims.ImsSsInfo;
 import android.text.TextUtils;
 
+import com.android.ims.ImsCall;
 import com.android.ims.ImsEcbm;
 import com.android.ims.ImsEcbmStateListener;
 import com.android.ims.ImsException;
@@ -103,6 +108,9 @@ import java.io.PrintWriter;
 import java.util.ArrayList;
 import java.util.List;
 
+import org.codeaurora.ims.QtiCallConstants;
+import org.codeaurora.ims.utils.QtiImsExtUtils;
+
 /**
  * {@hide}
  */
@@ -232,11 +240,13 @@ public class ImsPhone extends ImsPhoneBase {
         final String mSetCfNumber;
         final Message mOnComplete;
         final boolean mIsCfu;
+        final int mServiceClass;
 
-        Cf(String cfNumber, boolean isCfu, Message onComplete) {
+        Cf(String cfNumber, boolean isCfu, Message onComplete, int serviceClass) {
             mSetCfNumber = cfNumber;
             mIsCfu = isCfu;
             mOnComplete = onComplete;
+            mServiceClass = serviceClass;
         }
     }
 
@@ -282,6 +292,14 @@ public class ImsPhone extends ImsPhoneBase {
         mDefaultPhone.registerForServiceStateChanged(this, EVENT_SERVICE_STATE_CHANGED, null);
         // Force initial roaming state update later, on EVENT_CARRIER_CONFIG_CHANGED.
         // Settings provider or CarrierConfig may not be loaded now.
+
+        // Register receiver for sending RTT text message and
+        // for receving RTT Operation
+        // .i.e.Upgrade Initiate, Upgrade accept, Upgrade reject
+        IntentFilter filter = new IntentFilter();
+        filter.addAction(QtiCallConstants.ACTION_SEND_RTT_TEXT);
+        filter.addAction(QtiCallConstants.ACTION_RTT_OPERATION);
+        mDefaultPhone.getContext().registerReceiver(mRttReceiver, filter);
     }
 
     //todo: get rid of this function. It is not needed since parentPhone obj never changes
@@ -301,6 +319,7 @@ public class ImsPhone extends ImsPhoneBase {
             mDefaultPhone.getServiceStateTracker().
                     unregisterForDataRegStateOrRatChanged(this);
             mDefaultPhone.unregisterForServiceStateChanged(this);
+            mDefaultPhone.getContext().unregisterReceiver(mRttReceiver);
         }
     }
 
@@ -331,6 +350,13 @@ public class ImsPhone extends ImsPhoneBase {
         return mCT;
     }
 
+    public void setVoiceCallForwardingFlag(int line, boolean enable, String number) {
+        IccRecords r = mDefaultPhone.getIccRecords();
+        if (r != null) {
+            setVoiceCallForwardingFlag(r, line, enable, number);
+        }
+    }
+
     public ImsExternalCallTracker getExternalCallTracker() {
         return mExternalCallTracker;
     }
@@ -663,9 +689,19 @@ public class ImsPhone extends ImsPhoneBase {
     private Connection dialInternal(String dialString, DialArgs dialArgs,
                                     ResultReceiver wrappedCallback)
             throws CallStateException {
-
-        // Need to make sure dialString gets parsed properly
-        String newDialString = PhoneNumberUtils.stripSeparators(dialString);
+        boolean isConferenceUri = false;
+        boolean isSkipSchemaParsing = false;
+        if (dialArgs.intentExtras != null) {
+            isConferenceUri = dialArgs.intentExtras.getBoolean(
+                    TelephonyProperties.EXTRA_DIAL_CONFERENCE_URI, false);
+            isSkipSchemaParsing = dialArgs.intentExtras.getBoolean(
+                    TelephonyProperties.EXTRA_SKIP_SCHEMA_PARSING, false);
+        }
+        String newDialString = dialString;
+        // Need to make sure dialString gets parsed properly.
+        if (!isConferenceUri && !isSkipSchemaParsing) {
+            newDialString = PhoneNumberUtils.stripSeparators(dialString);
+        }
 
         // handle in-call MMI first if applicable
         if (handleInCallMmiCommands(newDialString)) {
@@ -725,6 +761,11 @@ public class ImsPhone extends ImsPhoneBase {
     }
 
     @Override
+    public void addParticipant(String dialString) throws CallStateException {
+        mCT.addParticipant(dialString);
+    }
+
+    @Override
     public void
     sendDtmf(char c) {
         if (!PhoneNumberUtils.is12Key(c)) {
@@ -889,15 +930,24 @@ public class ImsPhone extends ImsPhoneBase {
     @Override
     public void getCallForwardingOption(int commandInterfaceCFReason,
             Message onComplete) {
-        if (DBG) logd("getCallForwardingOption reason=" + commandInterfaceCFReason);
+        getCallForwardingOption(commandInterfaceCFReason,
+            SERVICE_CLASS_VOICE, onComplete);
+    }
+
+    @Override
+    public void getCallForwardingOption(int commandInterfaceCFReason,
+            int commandInterfaceServiceClass, Message onComplete) {
+        if (DBG) Rlog.d(LOG_TAG, "getCallForwardingOption reason=" + commandInterfaceCFReason +
+                "serviceclass =" + commandInterfaceServiceClass);
         if (isValidCommandInterfaceCFReason(commandInterfaceCFReason)) {
-            if (DBG) logd("requesting call forwarding query.");
+            if (DBG) Rlog.d(LOG_TAG, "requesting call forwarding query.");
             Message resp;
             resp = obtainMessage(EVENT_GET_CALL_FORWARD_DONE, onComplete);
 
             try {
                 ImsUtInterface ut = mCT.getUtInterface();
-                ut.queryCallForward(getConditionFromCFReason(commandInterfaceCFReason), null, resp);
+                ut.queryCallForward(getConditionFromCFReason(commandInterfaceCFReason), null,
+                        commandInterfaceServiceClass, resp);
             } catch (ImsException e) {
                 sendErrorResponse(onComplete, e);
             }
@@ -916,6 +966,7 @@ public class ImsPhone extends ImsPhoneBase {
                 CommandsInterface.SERVICE_CLASS_VOICE, timerSeconds, onComplete);
     }
 
+    @Override
     public void setCallForwardingOption(int commandInterfaceCFAction,
             int commandInterfaceCFReason,
             String dialingNumber,
@@ -930,7 +981,7 @@ public class ImsPhone extends ImsPhoneBase {
                 (isValidCommandInterfaceCFReason(commandInterfaceCFReason))) {
             Message resp;
             Cf cf = new Cf(dialingNumber, GsmMmiCode.isVoiceUnconditionalForwarding(
-                    commandInterfaceCFReason, serviceClass), onComplete);
+                    commandInterfaceCFReason, serviceClass), onComplete, serviceClass);
             resp = obtainMessage(EVENT_SET_CALL_FORWARD_DONE,
                     isCfEnable(commandInterfaceCFAction) ? 1 : 0, 0, cf);
 
@@ -1266,11 +1317,17 @@ public class ImsPhone extends ImsPhoneBase {
     @Override
     public void registerForSuppServiceNotification(Handler h, int what, Object obj) {
         mSsnRegistrants.addUnique(h, what, obj);
+        if (mSsnRegistrants.size() == 1) {
+            mDefaultPhone.mCi.setSuppServiceNotifications(true, null);
+        }
     }
 
     @Override
     public void unregisterForSuppServiceNotification(Handler h) {
         mSsnRegistrants.remove(h);
+        if (mSsnRegistrants.size() == 0) {
+            mDefaultPhone.mCi.setSuppServiceNotifications(false, null);
+        }
     }
 
     @Override
@@ -1283,14 +1340,27 @@ public class ImsPhone extends ImsPhoneBase {
         return mDefaultPhone.getPhoneId();
     }
 
+    public IccRecords getIccRecords() {
+        return mDefaultPhone.getIccRecords();
+    }
+
     private CallForwardInfo getCallForwardInfo(ImsCallForwardInfo info) {
         CallForwardInfo cfInfo = new CallForwardInfo();
         cfInfo.status = info.getStatus();
         cfInfo.reason = getCFReasonFromCondition(info.getCondition());
-        cfInfo.serviceClass = SERVICE_CLASS_VOICE;
         cfInfo.toa = info.getToA();
         cfInfo.number = info.getNumber();
         cfInfo.timeSeconds = info.getTimeSeconds();
+        //Check if the service class signifies Video call forward
+        //As per 3GPP TS 29002 MAP Specification : Section 17.7.10, the BearerServiceCode for
+        //"allDataCircuitAsynchronous" is '01010000' ( i.e. 80).
+        //Hence, SERVICE_CLASS_DATA_SYNC (1<<4) and SERVICE_CLASS_PACKET (1<<6)
+        //together make video service class.
+        if(info.mServiceClass == (SERVICE_CLASS_DATA_SYNC + SERVICE_CLASS_PACKET)) {
+            cfInfo.serviceClass = info.getServiceClass();
+        } else {
+            cfInfo.serviceClass = SERVICE_CLASS_VOICE;
+        }
         return cfInfo;
     }
 
@@ -1315,7 +1385,12 @@ public class ImsPhone extends ImsPhoneBase {
         } else {
             for (int i = 0, s = infos.length; i < s; i++) {
                 if (infos[i].getCondition() == ImsUtInterface.CDIV_CF_UNCONDITIONAL) {
-                    if (r != null) {
+                    //Check if the service class signifies Video call forward
+                    if (infos[i].mServiceClass == (SERVICE_CLASS_DATA_SYNC +
+                                SERVICE_CLASS_PACKET)) {
+                        setVideoCallForwardingPreference(infos[i].getStatus() == 1);
+                        notifyCallForwardingIndicator();
+                    } else if (r != null) {
                         setVoiceCallForwardingFlag(r, 1, (infos[i].getStatus() == 1),
                                 infos[i].getNumber());
                     }
@@ -1381,8 +1456,13 @@ public class ImsPhone extends ImsPhoneBase {
             case EVENT_SET_CALL_FORWARD_DONE:
                 IccRecords r = mDefaultPhone.getIccRecords();
                 Cf cf = (Cf) ar.userObj;
-                if (cf.mIsCfu && ar.exception == null && r != null) {
-                    setVoiceCallForwardingFlag(r, 1, msg.arg1 == 1, cf.mSetCfNumber);
+                if (cf.mIsCfu && ar.exception == null) {
+                    if (cf.mServiceClass == (SERVICE_CLASS_DATA_SYNC + SERVICE_CLASS_PACKET)) {
+                        setVideoCallForwardingPreference(msg.arg1 == 1);
+                        notifyCallForwardingIndicator();
+                    } else if (r != null && cf.mServiceClass == SERVICE_CLASS_VOICE) {
+                        setVoiceCallForwardingFlag(r, 1, msg.arg1 == 1, cf.mSetCfNumber);
+                    }
                 }
                 sendResponse(cf.mOnComplete, null, ar.exception);
                 break;
@@ -1436,9 +1516,13 @@ public class ImsPhone extends ImsPhoneBase {
                 if (VDBG) logd("EVENT_SERVICE_STATE_CHANGED");
                 ar = (AsyncResult) msg.obj;
                 ServiceState newServiceState = (ServiceState) ar.result;
-                // only update if roaming status changed
-                if (mRoaming != newServiceState.getRoaming()) {
-                    if (DBG) logd("Roaming state changed");
+                // only update if roaming status changed and voice or data is in service.
+                // The STATE_IN_SERVICE is checked to prevent wifi calling mode change when phone
+                // moves from roaming to no service.
+                if (mRoaming != newServiceState.getRoaming() &&
+                           (newServiceState.getVoiceRegState() == ServiceState.STATE_IN_SERVICE ||
+                           newServiceState.getDataRegState() == ServiceState.STATE_IN_SERVICE)) {
+                    if (DBG) logd("Roaming state changed- " + mRoaming);
                     updateRoamingState(newServiceState.getRoaming());
                 }
                 break;
@@ -1800,6 +1884,11 @@ public class ImsPhone extends ImsPhoneBase {
         mDefaultPhone.setBroadcastEmergencyCallStateChanges(broadcast);
     }
 
+    @Override
+    public void notifyCallForwardingIndicator() {
+        mDefaultPhone.notifyCallForwardingIndicator();
+    }
+
     @VisibleForTesting
     public PowerManager.WakeLock getWakeLock() {
         return mWakeLock;
@@ -1829,6 +1918,209 @@ public class ImsPhone extends ImsPhoneBase {
         return tm.isNetworkRoaming();
     }
 
+    private BroadcastReceiver mRttReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            if (QtiCallConstants.ACTION_SEND_RTT_TEXT.equals(intent.getAction())) {
+                Rlog.d(LOG_TAG, "RTT: Received ACTION_SEND_RTT_TEXT");
+                String data = intent.getStringExtra(QtiCallConstants.RTT_TEXT_VALUE);
+                sendRttMessage(data);
+            } else if (QtiCallConstants.ACTION_RTT_OPERATION.equals(intent.getAction())) {
+                Rlog.d(LOG_TAG, "RTT: Received ACTION_RTT_OPERATION");
+                int data = intent.getIntExtra(QtiCallConstants.RTT_OPERATION_TYPE, 0);
+                checkIfModifyRequestOrResponse(data);
+            } else {
+                Rlog.d(LOG_TAG, "RTT: unknown intent");
+            }
+        }
+    };
+
+    /**
+     * Sends Rtt message
+     * Rtt Message can be sent only when -
+     * operating mode is RTT_FULL and for non-VT calls only based on config
+     *
+     * @param data The Rtt text to be sent
+     */
+    public void sendRttMessage(String data) {
+        ImsCall imsCall = getForegroundCall().getImsCall();
+        if (imsCall == null) {
+            Rlog.d(LOG_TAG, "RTT: imsCall null");
+            return;
+        }
+
+        if (!imsCall.isRttCall() || !isFgCallActive()) {
+            return;
+        }
+
+        // Check for empty message
+        if (TextUtils.isEmpty(data)) {
+            Rlog.d(LOG_TAG, "RTT: Text null");
+            return;
+        }
+
+        if (!isRttVtCallAllowed(imsCall)) {
+            Rlog.d(LOG_TAG, "RTT: InCorrect mode");
+            return;
+        }
+
+        Rlog.d(LOG_TAG, "RTT: sendRttMessage");
+        imsCall.sendRttMessage(data);
+    }
+
+    /**
+     * Sends RTT Upgrade request
+     *
+     * @param to: expected profile
+     */
+    public void sendRttModifyRequest(ImsCallProfile to) {
+        Rlog.d(LOG_TAG, "RTT: sendRttModifyRequest");
+        ImsCall imsCall = getForegroundCall().getImsCall();
+        if (imsCall == null) {
+            Rlog.d(LOG_TAG, "RTT: imsCall null");
+            return;
+        }
+
+        try {
+            imsCall.sendRttModifyRequest(to);
+        } catch (ImsException e) {
+            Rlog.e(LOG_TAG, "RTT: sendRttModifyRequest exception = " + e);
+        }
+    }
+
+    /**
+     * Sends RTT Upgrade response
+     *
+     * @param data : response for upgrade
+     */
+    public void sendRttModifyResponse(int response) {
+        ImsCall imsCall = getForegroundCall().getImsCall();
+        if (imsCall == null) {
+            Rlog.d(LOG_TAG, "RTT: imsCall null");
+            return;
+        }
+
+        if (!isRttVtCallAllowed(imsCall)) {
+            Rlog.d(LOG_TAG, "RTT: Not allowed for VT");
+            return;
+        }
+
+        Rlog.d(LOG_TAG, "RTT: sendRttModifyResponse");
+        imsCall.sendRttModifyResponse(mapRequestToResponse(response));
+    }
+
+    // Utility to check if the value coming in intent is for upgrade initiate or upgrade response
+    private void checkIfModifyRequestOrResponse(int data) {
+        if (!(isRttSupported() && (isRttOn() || isInEmergencyCall())) || !isFgCallActive()) {
+            return;
+        }
+
+        Rlog.d(LOG_TAG, "RTT: checkIfModifyRequestOrResponse data =  " + data);
+        switch (data) {
+            case QtiCallConstants.RTT_UPGRADE_INITIATE:
+                // Rtt Upgrade means enable Rtt
+                packRttModifyRequestToProfile(ImsStreamMediaProfile.RTT_MODE_FULL);
+                break;
+            case QtiCallConstants.RTT_DOWNGRADE_INITIATE:
+                // Rtt downrade means disable Rtt
+                packRttModifyRequestToProfile(ImsStreamMediaProfile.RTT_MODE_DISABLED);
+                break;
+            case QtiCallConstants.RTT_UPGRADE_CONFIRM:
+            case QtiCallConstants.RTT_UPGRADE_REJECT:
+                sendRttModifyResponse(data);
+                break;
+        }
+    }
+
+    private void packRttModifyRequestToProfile(int data) {
+        if (!canSendRttModifyRequest()) {
+            Rlog.d(LOG_TAG, "RTT: cannot send rtt modify request");
+            return;
+        }
+
+        ImsCallProfile fromProfile = getForegroundCall().getImsCall().getCallProfile();
+        ImsCallProfile toProfile = new ImsCallProfile(fromProfile.mServiceType,
+                fromProfile.mCallType);
+        toProfile.mMediaProfile.setRttMode(data);
+
+        Rlog.d(LOG_TAG, "RTT: packRttModifyRequestToProfile");
+        sendRttModifyRequest(toProfile);
+    }
+
+    private boolean canSendRttModifyRequest() {
+        ImsCall imsCall = getForegroundCall().getImsCall();
+        if (imsCall == null) {
+            Rlog.d(LOG_TAG, "RTT: imsCall null");
+            return false;
+        }
+
+        return true;
+    }
+
+    private boolean mapRequestToResponse(int response) {
+        switch (response) {
+            case QtiCallConstants.RTT_UPGRADE_CONFIRM:
+                return true;
+            case QtiCallConstants.RTT_UPGRADE_REJECT:
+                return false;
+            default:
+                return false;
+        }
+    }
+
+    /*
+     * Returns true if Mode is RTT_FULL, false otherwise
+     */
+    private boolean isInFullRttMode() {
+        int mode = QtiImsExtUtils.getRttOperatingMode(mContext);
+        Rlog.d(LOG_TAG, "RTT: isInFullRttMode mode = " + mode);
+        return (mode == QtiCallConstants.RTT_MODE_FULL);
+    }
+
+    /*
+     * Rtt for VT calls is not supported for certain operators
+     * Check the config and process the request
+     */
+    public boolean isRttVtCallAllowed(ImsCall call) {
+        int mode = QtiImsExtUtils.getRttOperatingMode(mContext);
+        Rlog.d(LOG_TAG, "RTT: isRttVtCallAllowed mode = " + mode);
+
+        if (call.getCallProfile().isVideoCall() &&
+                !QtiImsExtUtils.isRttSupportedOnVtCalls(mPhoneId, mContext)) {
+            return false;
+        }
+        return true;
+    }
+
+    public boolean isRttSupported() {
+        if (!QtiImsExtUtils.isRttSupported(mPhoneId, mContext)) {
+            Rlog.d(LOG_TAG, "RTT: RTT is not supported");
+            return false;
+        }
+        Rlog.d(LOG_TAG, "RTT: rtt supported = " +
+                QtiImsExtUtils.isRttSupported(mPhoneId, mContext) + ", Rtt mode = " +
+                QtiImsExtUtils.getRttOperatingMode(mContext));
+        return true;
+    }
+
+    public boolean isRttOn() {
+        if (!QtiImsExtUtils.isRttOn(mContext)) {
+            Rlog.d(LOG_TAG, "RTT: RTT is off");
+            return false;
+        }
+        Rlog.d(LOG_TAG, "RTT: Rtt on = " + QtiImsExtUtils.isRttOn(mContext));
+        return true;
+    }
+
+    public boolean isFgCallActive() {
+        // process the request only if foreground is active
+        if (ImsPhoneCall.State.ACTIVE != getForegroundCall().getState()) {
+            Rlog.d(LOG_TAG, "RTT: isFgCallActive fg call not active");
+            return false;
+        }
+        return true;
+    }
+
     @Override
     public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
         pw.println("ImsPhone extends:");
diff --git a/src/java/com/android/internal/telephony/imsphone/ImsPhoneCallTracker.java b/src/java/com/android/internal/telephony/imsphone/ImsPhoneCallTracker.java
index 7a5275c..355c3b8 100644
--- a/src/java/com/android/internal/telephony/imsphone/ImsPhoneCallTracker.java
+++ b/src/java/com/android/internal/telephony/imsphone/ImsPhoneCallTracker.java
@@ -55,6 +55,7 @@ import android.telephony.ServiceState;
 import android.telephony.SubscriptionManager;
 import android.telephony.TelephonyManager;
 import android.telephony.ims.ImsCallProfile;
+import android.telephony.ims.ImsCallSession;
 import android.telephony.ims.ImsReasonInfo;
 import android.telephony.ims.ImsStreamMediaProfile;
 import android.telephony.ims.ImsSuppServiceNotification;
@@ -110,6 +111,9 @@ import java.util.Map;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.regex.Pattern;
 
+import org.codeaurora.ims.QtiCallConstants;
+import org.codeaurora.ims.utils.QtiImsExtUtils;
+
 /**
  * {@hide}
  */
@@ -190,6 +194,7 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
                     }
                 }
                 conn.setAllowAddCallDuringVideoCall(mAllowAddCallDuringVideoCall);
+                conn.setAllowHoldingVideoCall(mAllowHoldingVideoCall);
                 addConnection(conn);
 
                 setVideoCallProvider(conn, imsCall);
@@ -341,6 +346,7 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
     private boolean mIgnoreDataEnabledChangedForVideoCalls = false;
     private boolean mIsViLteDataMetered = false;
     private boolean mAlwaysPlayRemoteHoldTone = false;
+    private boolean mIgnoreResetUtCapability = false;
     private boolean mAutoRetryFailedWifiEmergencyCall = false;
 
     private String mLastDialString = null;
@@ -369,6 +375,14 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
      */
     private boolean mAllowAddCallDuringVideoCall = true;
 
+
+    /**
+     * Carrier configuration option which determines whether holding a video call
+     * should be allowed.
+     */
+    private boolean mAllowHoldingVideoCall = true;
+
+
     /**
      * Carrier configuration option which determines whether to notify the connection if a handover
      * to wifi fails.
@@ -674,7 +688,7 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
      * PhoneNumberUtils.
      */
     private PhoneNumberUtilsProxy mPhoneNumberUtilsProxy = (String string) -> {
-        return PhoneNumberUtils.isEmergencyNumber(string);
+        return mPhone.getDefaultPhone().isEmergencyNumber(string);
     };
 
     private final ImsManager.Connector mImsManagerConnector;
@@ -914,7 +928,7 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
             throw new CallStateException("service not available");
         }
 
-        if (!canDial()) {
+        if (!canDial() || !canAddVideoCallDuringImsAudioCall(videoState)) {
             throw new CallStateException("cannot dial in current state");
         }
 
@@ -931,6 +945,7 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
         }
 
         boolean holdBeforeDial = false;
+        boolean hangupBeforeDial = false;
 
         // The new call must be assigned to the foreground call.
         // That call must be idle, so place anything that's
@@ -945,7 +960,17 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
             // Cache the video state for pending MO call.
             mPendingCallVideoState = videoState;
             mPendingIntentExtras = dialArgs.intentExtras;
-            switchWaitingOrHoldingAndActive();
+
+            if (shouldDisconnectActiveCallOnDial(isEmergencyNumber)) {
+                holdBeforeDial = false;
+                hangupBeforeDial = true;
+                /* hangup active call and let onCallTerminated() to dial
+                   the pending MO Call */
+                log("dial, hangingup active call");
+                mForegroundCall.hangup();
+            } else {
+                switchWaitingOrHoldingAndActive();
+            }
         }
 
         ImsPhoneCall.State fgState = ImsPhoneCall.State.IDLE;
@@ -973,7 +998,7 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
             mLastDialArgs = dialArgs;
             mPendingMO = new ImsPhoneConnection(mPhone,
                     checkForTestEmergencyNumber(dialString), this, mForegroundCall,
-                    isEmergencyNumber);
+                    isEmergencyNumber, dialArgs.intentExtras);
             mPendingMO.setVideoState(videoState);
             if (dialArgs.rttTextStream != null) {
                 log("dial: setting RTT stream on mPendingMO");
@@ -982,7 +1007,7 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
         }
         addConnection(mPendingMO);
 
-        if (!holdBeforeDial) {
+        if (!holdBeforeDial && !hangupBeforeDial) {
             if ((!isPhoneInEcmMode) || (isPhoneInEcmMode && isEmergencyNumber)) {
                 dialInternal(mPendingMO, clirMode, videoState, dialArgs.intentExtras);
             } else {
@@ -995,6 +1020,7 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
                 mPhone.setOnEcbModeExitResponse(this, EVENT_EXIT_ECM_RESPONSE_CDMA, null);
                 pendingCallClirMode = clirMode;
                 mPendingCallVideoState = videoState;
+                mPendingIntentExtras = dialArgs.intentExtras;
                 pendingCallInEcm = true;
             }
         }
@@ -1013,6 +1039,25 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
         return mImsManager.isServiceReady();
     }
 
+    public void addParticipant(String dialString) throws CallStateException {
+        if (mForegroundCall != null) {
+            ImsCall imsCall = mForegroundCall.getImsCall();
+            if (imsCall == null) {
+                loge("addParticipant : No foreground ims call");
+            } else {
+                ImsCallSession imsCallSession = imsCall.getCallSession();
+                if (imsCallSession != null) {
+                    String[] callees = new String[] { dialString };
+                    imsCallSession.inviteParticipants(callees);
+                } else {
+                    loge("addParticipant : ImsCallSession does not exist");
+                }
+            }
+        } else {
+            loge("addParticipant : Foreground call does not exist");
+        }
+    }
+
     private boolean shouldNumberBePlacedOnIms(boolean isEmergency, String number) {
         int processCallResult;
         try {
@@ -1090,6 +1135,9 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
         mAllowAddCallDuringVideoCall =
                 carrierConfig.getBoolean(
                         CarrierConfigManager.KEY_ALLOW_ADD_CALL_DURING_VIDEO_CALL_BOOL);
+        mAllowHoldingVideoCall =
+                carrierConfig.getBoolean(
+                        CarrierConfigManager.KEY_ALLOW_HOLDING_VIDEO_CALL_BOOL);
         mNotifyVtHandoverToWifiFail = carrierConfig.getBoolean(
                 CarrierConfigManager.KEY_NOTIFY_VT_HANDOVER_TO_WIFI_FAILURE_BOOL);
         mSupportDowngradeVtToAudio = carrierConfig.getBoolean(
@@ -1106,6 +1154,8 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
                 CarrierConfigManager.KEY_SUPPORT_PAUSE_IMS_VIDEO_CALLS_BOOL);
         mAlwaysPlayRemoteHoldTone = carrierConfig.getBoolean(
                 CarrierConfigManager.KEY_ALWAYS_PLAY_REMOTE_HOLD_TONE_BOOL);
+        mIgnoreResetUtCapability =  carrierConfig.getBoolean(
+                CarrierConfigManager.KEY_IGNORE_RESET_UT_CAPABILITY_BOOL);
         mAutoRetryFailedWifiEmergencyCall = carrierConfig.getBoolean(
                 CarrierConfigManager.KEY_AUTO_RETRY_FAILED_WIFI_EMERGENCY_CALL);
 
@@ -1160,8 +1210,20 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
             return;
         }
 
-        if (conn.getAddress()== null || conn.getAddress().length() == 0
-                || conn.getAddress().indexOf(PhoneNumberUtils.WILD) >= 0) {
+        boolean isConferenceUri = false;
+        boolean isSkipSchemaParsing = false;
+
+        if (intentExtras != null) {
+            isConferenceUri = intentExtras.getBoolean(
+                    TelephonyProperties.EXTRA_DIAL_CONFERENCE_URI, false);
+            isSkipSchemaParsing = intentExtras.getBoolean(
+                    TelephonyProperties.EXTRA_SKIP_SCHEMA_PARSING, false);
+        }
+
+
+        if (!isConferenceUri && !isSkipSchemaParsing
+                && (conn.getAddress()== null || conn.getAddress().length() == 0
+                || conn.getAddress().indexOf(PhoneNumberUtils.WILD) >= 0)) {
             // Phone number is invalid
             conn.setDisconnectCause(DisconnectCause.INVALID_NUMBER);
             sendEmptyMessageDelayed(EVENT_HANGUP_PENDINGMO, TIMEOUT_HANGUP_PENDINGMO);
@@ -1180,6 +1242,8 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
             String[] callees = new String[] { conn.getAddress() };
             ImsCallProfile profile = mImsManager.createCallProfile(serviceType, callType);
             profile.setCallExtraInt(ImsCallProfile.EXTRA_OIR, clirMode);
+            profile.setCallExtraBoolean(TelephonyProperties.EXTRAS_IS_CONFERENCE_URI,
+                    isConferenceUri);
 
             // Translate call subject intent-extra from Telecom-specific extra key to the
             // ImsCallProfile key.
@@ -1213,6 +1277,7 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
                 // being sent to the lower layers/to the network.
             }
 
+            profile = setRttModeBasedOnOperator(profile);
             ImsCall imsCall = mImsManager.makeCall(profile, callees, mImsCallListener);
             conn.setImsCall(imsCall);
 
@@ -1221,6 +1286,7 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
 
             setVideoCallProvider(conn, imsCall);
             conn.setAllowAddCallDuringVideoCall(mAllowAddCallDuringVideoCall);
+            conn.setAllowHoldingVideoCall(mAllowHoldingVideoCall);
         } catch (ImsException e) {
             loge("dialInternal : " + e);
             conn.setDisconnectCause(DisconnectCause.ERROR_UNSPECIFIED);
@@ -1245,6 +1311,7 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
             throw new CallStateException("cannot accept call");
         }
 
+        ImsStreamMediaProfile mediaProfile = new ImsStreamMediaProfile();
         if ((mRingingCall.getState() == ImsPhoneCall.State.WAITING)
                 && mForegroundCall.getState().isAlive()) {
             setMute(false);
@@ -1264,7 +1331,9 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
                 // We need to disconnect the foreground call before answering the background call.
                 mForegroundCall.hangup();
                 try {
-                    ringingCall.accept(ImsCallProfile.getCallTypeFromVideoState(videoState));
+                    mediaProfile = addRttAttributeIfRequired(ringingCall, mediaProfile);
+                    ringingCall.accept(ImsCallProfile.getCallTypeFromVideoState(videoState),
+                            mediaProfile);
                 } catch (ImsException e) {
                     throw new CallStateException("cannot accept call");
                 }
@@ -1278,7 +1347,9 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
             try {
                 ImsCall imsCall = mRingingCall.getImsCall();
                 if (imsCall != null) {
-                    imsCall.accept(ImsCallProfile.getCallTypeFromVideoState(videoState));
+                    mediaProfile = addRttAttributeIfRequired(imsCall, mediaProfile);
+                    imsCall.accept(ImsCallProfile.getCallTypeFromVideoState(videoState),
+                            mediaProfile);
                     mMetrics.writeOnImsCommand(mPhone.getPhoneId(), imsCall.getSession(),
                             ImsCommand.IMS_CMD_ACCEPT);
                 } else {
@@ -1447,6 +1518,25 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
             && !mForegroundCall.isFull();
     }
 
+    private boolean canAddVideoCallDuringImsAudioCall(int videoState) {
+        if (mAllowHoldingVideoCall) {
+            return true;
+        }
+
+        ImsCall call = mForegroundCall.getImsCall();
+        if (call == null) {
+            call = mBackgroundCall.getImsCall();
+        }
+
+        boolean isImsAudioCallActiveOrHolding = (mForegroundCall.getState() == Call.State.ACTIVE ||
+               mBackgroundCall.getState() == Call.State.HOLDING) && call != null &&
+               !call.isVideoCall();
+
+        /* return TRUE if there doesn't exist ims audio call in either active
+           or hold states */
+        return !isImsAudioCallActiveOrHolding || !VideoProfile.isVideo(videoState);
+    }
+
     public boolean canDial() {
         boolean ret;
         String disableCall = SystemProperties.get(
@@ -1746,8 +1836,13 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
                 //accept waiting call after holding background call
                 ImsCall imsCall = mRingingCall.getImsCall();
                 if (imsCall != null) {
+                    ImsStreamMediaProfile mediaProfile = new ImsStreamMediaProfile();
+
+                    mediaProfile = addRttAttributeIfRequired(imsCall, mediaProfile);
+
                     imsCall.accept(
-                        ImsCallProfile.getCallTypeFromVideoState(mPendingCallVideoState));
+                            ImsCallProfile.getCallTypeFromVideoState(mPendingCallVideoState),
+                            mediaProfile);
                     mMetrics.writeOnImsCommand(mPhone.getPhoneId(), imsCall.getSession(),
                             ImsCommand.IMS_CMD_ACCEPT);
                 }
@@ -1958,6 +2053,16 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
         return code;
     }
 
+    @VisibleForTesting
+    public boolean getSwitchingFgAndBgCallsValue() {
+        return mSwitchingFgAndBgCalls;
+    }
+
+    @VisibleForTesting
+    public void setSwitchingFgAndBgCallsValue(boolean value) {
+        mSwitchingFgAndBgCalls = value;
+    }
+
     /**
      * Maps an {@link ImsReasonInfo} reason code to a {@link DisconnectCause} cause code.
      * The {@link Call.State} provided is the state of the call prior to disconnection.
@@ -2329,8 +2434,9 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
                 if (mRingingCall.getState().isRinging()) {
                     // Drop pending MO. We should address incoming call first
                     mPendingMO = null;
-                } else if (mPendingMO != null) {
-                    sendEmptyMessage(EVENT_DIAL_PENDINGMO);
+                } else if (mPendingMO != null && !mPendingMO.getState().isDialing()) {
+                        //Don't re-send a dial request if already in DIALING/ALERTING state.
+                        sendEmptyMessage(EVENT_DIAL_PENDINGMO);
                 }
             }
 
@@ -2444,6 +2550,9 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
                         mPendingMO.setDisconnectCause(DisconnectCause.ERROR_UNSPECIFIED);
                         sendEmptyMessageDelayed(EVENT_HANGUP_PENDINGMO, TIMEOUT_HANGUP_PENDINGMO);
                     }
+                    if (imsCall != mCallExpectedToResume) {
+                        mCallExpectedToResume = null;
+                    }
                 }
                 mPhone.notifySuppServiceFailed(Phone.SuppService.HOLD);
             }
@@ -2616,6 +2725,8 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
             // based on the user facing UI.
             mPhone.notifySuppServiceFailed(Phone.SuppService.CONFERENCE);
 
+            call.resetIsMergeRequestedByConf(false);
+
             // Start plumbing this even through Telecom so other components can take
             // appropriate action.
             ImsPhoneConnection conn = findConnection(call);
@@ -2670,6 +2781,9 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
                 if (conn.getDisconnectCause() == DisconnectCause.NOT_DISCONNECTED) {
                     if (isHandoverToWifi) {
                         removeMessages(EVENT_CHECK_FOR_WIFI_HANDOVER);
+                        if (mIsViLteDataMetered) {
+                            conn.setVideoEnabled(true);
+                        }
 
                         if (mNotifyHandoverVideoFromLTEToWifi && mHasPerformedStartOfCallHandover) {
                             // This is a handover which happened mid-call (ie not the start of call
@@ -2689,7 +2803,11 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
                 }
 
                 if (isHandoverFromWifi && imsCall.isVideoCall()) {
-                    if (mNotifyHandoverVideoFromWifiToLTE &&    mIsDataEnabled) {
+                    if (mIsViLteDataMetered) {
+                        conn.setVideoEnabled(mIsDataEnabled);
+                    }
+
+                    if (mNotifyHandoverVideoFromWifiToLTE && mIsDataEnabled) {
                         if (conn.getDisconnectCause() == DisconnectCause.NOT_DISCONNECTED) {
                             log("onCallHandover :: notifying of WIFI to LTE handover.");
                             conn.onConnectionEvent(
@@ -2781,6 +2899,14 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
             }
         }
 
+        @Override
+        public void onCallSessionPropertyChanged(ImsCall imsCall, int property) {
+          ImsPhoneConnection conn = findConnection(imsCall);
+            if (conn != null) {
+                conn.onCallSessionPropertyChanged(property);
+            }
+        }
+
         /**
          * Handles a change to the multiparty state for an {@code ImsCall}.  Notifies the associated
          * {@link ImsPhoneConnection} of the change.
@@ -3513,6 +3639,22 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
         return new ImsException("no ims manager", ImsReasonInfo.CODE_LOCAL_ILLEGAL_STATE);
     }
 
+    private boolean shouldDisconnectActiveCallOnDial(boolean isEmergencyNumber) {
+        if (mAllowHoldingVideoCall) {
+            return false;
+        }
+
+        boolean isActiveVideoCall = false;
+        if (mForegroundCall.getState() == ImsPhoneCall.State.ACTIVE) {
+            ImsCall activeImsCall = mForegroundCall.getImsCall();
+            if (activeImsCall != null) {
+                isActiveVideoCall = activeImsCall.isVideoCall();
+            }
+        }
+
+       return (isActiveVideoCall && isEmergencyNumber);
+    }
+
     /**
      * Determines if answering an incoming call will cause the active call to be disconnected.
      * <p>
@@ -3611,6 +3753,10 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
         }
     }
 
+    public boolean isViLteDataMetered() {
+        return mIsViLteDataMetered;
+    }
+
     /**
      * Handler of data enabled changed event
      * @param enabled True if data is enabled, otherwise disabled.
@@ -3632,7 +3778,9 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
         // Inform connections that data has been disabled to ensure we turn off video capability
         // if this is an LTE call.
         for (ImsPhoneConnection conn : mConnections) {
-            conn.handleDataEnabledChange(enabled);
+            ImsCall imsCall = conn.getImsCall();
+            boolean isVideoEnabled = enabled || (imsCall != null && imsCall.isWifiCall());
+            conn.setVideoEnabled(isVideoEnabled);
         }
 
         int reasonCode;
@@ -3741,7 +3889,8 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
         if (imsCall != null) {
             if (conn.hasCapabilities(
                     Connection.Capability.SUPPORTS_DOWNGRADE_TO_VOICE_LOCAL |
-                            Connection.Capability.SUPPORTS_DOWNGRADE_TO_VOICE_REMOTE)) {
+                            Connection.Capability.SUPPORTS_DOWNGRADE_TO_VOICE_REMOTE)
+                            && !mSupportPauseVideo) {
 
                 // If the carrier supports downgrading to voice, then we can simply issue a
                 // downgrade to voice instead of terminating the call.
@@ -3764,7 +3913,24 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
 
     private void resetImsCapabilities() {
         log("Resetting Capabilities...");
-        mMmTelCapabilities = new MmTelFeature.MmTelCapabilities();
+        boolean tmpIsVideoCallEnabled = isVideoCallEnabled();
+
+        if (mIgnoreResetUtCapability) {
+            //UT capability should not be reset (for IMS deregistration and for IMS feature state
+            //not ready) and it should always depend on the modem indication for UT capability
+            mMmTelCapabilities.removeCapabilities(
+                    MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VOICE);
+            mMmTelCapabilities.removeCapabilities(
+                    MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VIDEO);
+            mMmTelCapabilities.removeCapabilities(
+                    MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_SMS);
+        } else {
+            mMmTelCapabilities = new MmTelFeature.MmTelCapabilities();
+        }
+        boolean isVideoEnabled = isVideoCallEnabled();
+        if (tmpIsVideoCallEnabled != isVideoEnabled) {
+            mPhone.notifyForVideoCapabilityChanged(isVideoEnabled);
+        }
     }
 
     /**
@@ -3930,4 +4096,43 @@ public class ImsPhoneCallTracker extends CallTracker implements ImsPullCall {
     public void setAlwaysPlayRemoteHoldTone(boolean shouldPlayRemoteHoldTone) {
         mAlwaysPlayRemoteHoldTone = shouldPlayRemoteHoldTone;
     }
+
+    // Update the Rtt attribute
+    private ImsCallProfile setRttModeBasedOnOperator(ImsCallProfile profile) {
+        if (!(mPhone.isRttSupported() && mPhone.isRttOn())) {
+            return profile;
+        }
+
+        int mode = QtiImsExtUtils.getRttOperatingMode(mPhone.getContext());
+
+        if (DBG) log("RTT: setRttModeBasedOnOperator mode = " + mode);
+
+        if (!QtiImsExtUtils.isRttSupportedOnVtCalls(mPhone.getPhoneId(), mPhone.getContext())
+                && profile.isVideoCall()) {
+            return profile;
+        }
+
+        profile.mMediaProfile.setRttMode(mode);
+        return profile;
+    }
+
+    // Accept the call as RTT if incoming call as RTT attribute set
+    private ImsStreamMediaProfile addRttAttributeIfRequired(ImsCall call,
+            ImsStreamMediaProfile mediaProfile) {
+
+        if (!mPhone.isRttSupported()) {
+            return mediaProfile;
+        }
+
+        ImsCallProfile profile = call.getCallProfile();
+        if (profile.mMediaProfile != null && profile.mMediaProfile.isRttCall() &&
+                (mPhone.isRttVtCallAllowed(call))) {
+            if (DBG) log("RTT: addRttAttributeIfRequired = " +
+                    profile.mMediaProfile.isRttCall());
+            // If RTT UI option is on, then incoming RTT call should always be accepted
+            // as RTT, irrespective of Modes
+            mediaProfile.setRttMode(ImsStreamMediaProfile.RTT_MODE_FULL);
+        }
+        return mediaProfile;
+    }
 }
diff --git a/src/java/com/android/internal/telephony/imsphone/ImsPhoneCommandInterface.java b/src/java/com/android/internal/telephony/imsphone/ImsPhoneCommandInterface.java
index 93a6d3e..b59b0bd 100644
--- a/src/java/com/android/internal/telephony/imsphone/ImsPhoneCommandInterface.java
+++ b/src/java/com/android/internal/telephony/imsphone/ImsPhoneCommandInterface.java
@@ -240,6 +240,10 @@ class ImsPhoneCommandInterface extends BaseCommands implements CommandsInterface
     }
 
     @Override
+    public void sendCdmaSms(byte[] pdu, Message result, boolean isExpectMore) {
+    }
+
+    @Override
     public void sendImsGsmSms (String smscPDU, String pdu,
             int retry, int messageRef, Message response) {
     }
diff --git a/src/java/com/android/internal/telephony/imsphone/ImsPhoneConnection.java b/src/java/com/android/internal/telephony/imsphone/ImsPhoneConnection.java
index 47b3624..e78ccc2 100644
--- a/src/java/com/android/internal/telephony/imsphone/ImsPhoneConnection.java
+++ b/src/java/com/android/internal/telephony/imsphone/ImsPhoneConnection.java
@@ -45,6 +45,7 @@ import com.android.internal.telephony.CallStateException;
 import com.android.internal.telephony.Connection;
 import com.android.internal.telephony.Phone;
 import com.android.internal.telephony.PhoneConstants;
+import com.android.internal.telephony.TelephonyProperties;
 import com.android.internal.telephony.UUSInfo;
 
 import java.util.Objects;
@@ -213,17 +214,37 @@ public class ImsPhoneConnection extends Connection implements
     /** This is an MO call, created when dialing */
     public ImsPhoneConnection(Phone phone, String dialString, ImsPhoneCallTracker ct,
             ImsPhoneCall parent, boolean isEmergency) {
+        this(phone, dialString, ct, parent, isEmergency, null);
+    }
+
+    /** This is an MO call, created when dialing */
+    public ImsPhoneConnection(Phone phone, String dialString, ImsPhoneCallTracker ct,
+            ImsPhoneCall parent, boolean isEmergency, Bundle extras) {
         super(PhoneConstants.PHONE_TYPE_IMS);
         createWakeLock(phone.getContext());
         acquireWakeLock();
+        boolean isConferenceUri = false;
+        boolean isSkipSchemaParsing = false;
+
+        if (extras != null) {
+            isConferenceUri = extras.getBoolean(
+                    TelephonyProperties.EXTRA_DIAL_CONFERENCE_URI, false);
+            isSkipSchemaParsing = extras.getBoolean(
+                    TelephonyProperties.EXTRA_SKIP_SCHEMA_PARSING, false);
+        }
 
         mOwner = ct;
         mHandler = new MyHandler(mOwner.getLooper());
 
         mDialString = dialString;
 
-        mAddress = PhoneNumberUtils.extractNetworkPortionAlt(dialString);
-        mPostDialString = PhoneNumberUtils.extractPostDialPortion(dialString);
+        if (isConferenceUri || isSkipSchemaParsing) {
+            mAddress = dialString;
+            mPostDialString = "";
+        } else {
+            mAddress = PhoneNumberUtils.extractNetworkPortionAlt(dialString);
+            mPostDialString = PhoneNumberUtils.extractPostDialPortion(dialString);
+        }
 
         //mIndex = -1;
 
@@ -275,6 +296,10 @@ public class ImsPhoneConnection extends Connection implements
                 capabilities = addCapability(capabilities,
                         Connection.Capability.SUPPORTS_VT_LOCAL_BIDIRECTIONAL);
                 break;
+            case ImsCallProfile.CALL_TYPE_UNKNOWN:
+                capabilities = removeCapability(capabilities,
+                        Connection.Capability.SUPPORTS_DOWNGRADE_TO_VOICE_LOCAL);
+                break;
         }
         return capabilities;
     }
@@ -291,6 +316,14 @@ public class ImsPhoneConnection extends Connection implements
                 capabilities = addCapability(capabilities,
                         Connection.Capability.SUPPORTS_VT_REMOTE_BIDIRECTIONAL);
                 break;
+            case ImsCallProfile.CALL_TYPE_UNKNOWN:
+                capabilities = removeCapability(capabilities,
+                        Connection.Capability.SUPPORTS_DOWNGRADE_TO_VOICE_REMOTE);
+                break;
+        }
+
+        if (remoteProfile.getMediaProfile().getRttMode() == ImsStreamMediaProfile.RTT_MODE_FULL) {
+            capabilities = addCapability(capabilities, Connection.Capability.SUPPORTS_RTT_REMOTE);
         }
         return capabilities;
     }
@@ -955,6 +988,15 @@ public class ImsPhoneConnection extends Connection implements
                 changed = true;
             }
 
+            if (!mOwner.isViLteDataMetered()) {
+                Rlog.v(LOG_TAG, "data is not metered");
+            } else {
+                if (mImsVideoCallProviderWrapper != null) {
+                    mImsVideoCallProviderWrapper.setIsVideoEnabled(
+                            hasCapabilities(Connection.Capability.SUPPORTS_VT_LOCAL_BIDIRECTIONAL));
+                }
+            }
+
             int newAudioQuality =
                     getAudioQualityFromCallProfile(localCallProfile, remoteCallProfile);
             if (getAudioQuality() != newAudioQuality) {
@@ -1019,6 +1061,12 @@ public class ImsPhoneConnection extends Connection implements
         mRttTextHandler.sendToInCall(message);
     }
 
+    public void onCallSessionPropertyChanged(int property) {
+        Bundle extras = new Bundle();
+        extras.putInt(android.telecom.Connection.EXTRA_CALL_PROPERTY, property);
+        onConnectionEvent(android.telecom.Connection.EVENT_CALL_PROPERTY_CHANGED, extras);
+    }
+
     public void setCurrentRttTextStream(android.telecom.Connection.RttTextStream rttTextStream) {
         synchronized (this) {
             mRttTextStream = rttTextStream;
@@ -1332,14 +1380,10 @@ public class ImsPhoneConnection extends Connection implements
         mShouldIgnoreVideoStateChanges = false;
     }
 
-    public void handleDataEnabledChange(boolean isDataEnabled) {
-        mIsVideoEnabled = isDataEnabled;
-        Rlog.i(LOG_TAG, "handleDataEnabledChange: isDataEnabled=" + isDataEnabled
+    public void setVideoEnabled(boolean isVideoEnabled) {
+        mIsVideoEnabled = isVideoEnabled;
+        Rlog.i(LOG_TAG, "setVideoEnabled: mIsVideoEnabled = " + mIsVideoEnabled
                 + "; updating local video availability.");
         updateMediaCapabilities(getImsCall());
-        if (mImsVideoCallProviderWrapper != null) {
-            mImsVideoCallProviderWrapper.setIsVideoEnabled(
-                    hasCapabilities(Connection.Capability.SUPPORTS_VT_LOCAL_BIDIRECTIONAL));
-        }
     }
 }
diff --git a/src/java/com/android/internal/telephony/imsphone/ImsPhoneMmiCode.java b/src/java/com/android/internal/telephony/imsphone/ImsPhoneMmiCode.java
index 87e51ec..814d713 100644
--- a/src/java/com/android/internal/telephony/imsphone/ImsPhoneMmiCode.java
+++ b/src/java/com/android/internal/telephony/imsphone/ImsPhoneMmiCode.java
@@ -800,7 +800,7 @@ public final class ImsPhoneMmiCode extends Handler implements MmiCode {
                 int time = siToTime(mSic);
 
                 if (isInterrogate()) {
-                    mPhone.getCallForwardingOption(reason,
+                    mPhone.getCallForwardingOption(reason, serviceClass,
                             obtainMessage(EVENT_QUERY_CF_COMPLETE, this));
                 } else {
                     int cfAction;
@@ -1090,12 +1090,22 @@ public final class ImsPhoneMmiCode extends Handler implements MmiCode {
                 ar = (AsyncResult) (msg.obj);
 
                 /*
-                * msg.arg1 = 1 means to set unconditional voice call forwarding
-                * msg.arg2 = 1 means to enable voice call forwarding
+                * msg.arg1 = 1 means to set unconditional voice/video call forwarding
+                * msg.arg2 = 1 means to enable voice/video call forwarding
                 */
                 if ((ar.exception == null) && (msg.arg1 == 1)) {
                     boolean cffEnabled = (msg.arg2 == 1);
-                    if (mIccRecords != null) {
+                    /*
+                    * As per 3GPP TS 29002 MAP Specification : Section 17.7.10,
+                    * the BearerServiceCode for "allDataCircuitAsynchronous" is '01010000'.
+                    * Hence, SERVICE_CLASS_DATA_SYNC (1<<4) and SERVICE_CLASS_PACKET (1<<6)
+                    * together make video service class.
+                    */
+                    if(siToServiceClass(mSib) == (SERVICE_CLASS_PACKET
+                                + SERVICE_CLASS_DATA_SYNC)) {
+                        mPhone.setVideoCallForwardingPreference(cffEnabled);
+                        mPhone.notifyCallForwardingIndicator();
+                    } else if (mIccRecords != null) {
                         mPhone.setVoiceCallForwardingFlag(1, cffEnabled, mDialingNumber);
                     }
                 }
@@ -1480,7 +1490,11 @@ public final class ImsPhoneMmiCode extends Handler implements MmiCode {
                 if (ssInfo != null) {
                     Rlog.d(LOG_TAG,
                             "onSuppSvcQueryComplete: ImsSsInfo mStatus = " + ssInfo.getStatus());
-                    if (ssInfo.getStatus() == ImsSsInfo.DISABLED) {
+                    if (ssInfo.getProvisionStatus() == ImsSsInfo.SERVICE_NOT_PROVISIONED) {
+                        sb.append(mContext.getText(
+                                com.android.internal.R.string.serviceNotProvisioned));
+                        mState = State.COMPLETE;
+                    } else if (ssInfo.getStatus() == ImsSsInfo.DISABLED) {
                         sb.append(mContext.getText(com.android.internal.R.string.serviceDisabled));
                         mState = State.COMPLETE;
                     } else if (ssInfo.getStatus() == ImsSsInfo.ENABLED) {
@@ -1752,7 +1766,15 @@ public final class ImsPhoneMmiCode extends Handler implements MmiCode {
                         Rlog.d(LOG_TAG, "setVoiceCallForwardingFlag done from SS Info.");
                         //Only CF status is set here as part of activation/registration,
                         //number is not available until interrogation.
-                        mPhone.setVoiceCallForwardingFlag(1, cffEnabled, null);
+                        if (ssData.serviceClass == (SERVICE_CLASS_PACKET
+                                    + SERVICE_CLASS_DATA_SYNC)) {
+                            Rlog.d(LOG_TAG, "setVideoCallForwardingFlag done from SS Info.");
+                            mPhone.setVideoCallForwardingPreference(cffEnabled);
+                            mPhone.notifyCallForwardingIndicator();
+                        } else {
+                            Rlog.d(LOG_TAG, "setVoiceCallForwardingFlag done from SS Info.");
+                            mPhone.setVoiceCallForwardingFlag(1, cffEnabled, null);
+                        }
                     } else {
                         Rlog.e(LOG_TAG, "setCallForwardingFlag aborted. sim records is null.");
                     }
diff --git a/src/java/com/android/internal/telephony/imsphone/ImsRttTextHandler.java b/src/java/com/android/internal/telephony/imsphone/ImsRttTextHandler.java
index eff2499..b8dc76e 100644
--- a/src/java/com/android/internal/telephony/imsphone/ImsRttTextHandler.java
+++ b/src/java/com/android/internal/telephony/imsphone/ImsRttTextHandler.java
@@ -124,11 +124,19 @@ public class ImsRttTextHandler extends Handler {
                     return;
                 }
                 mRttTextStream = (Connection.RttTextStream) msg.obj;
+                if (mRttTextStream == null) {
+                    Rlog.e(LOG_TAG, "RTT text stream is null");
+                    return;
+                }
                 mReaderThread = new InCallReaderThread(mRttTextStream);
                 mReaderThread.start();
                 break;
             case SEND_TO_INCALL:
                 String messageToIncall = (String) msg.obj;
+                if (mRttTextStream == null) {
+                    Rlog.e(LOG_TAG, "RTT text stream is null");
+                    return;
+                }
                 try {
                     mRttTextStream.write(messageToIncall);
                 } catch (IOException e) {
diff --git a/src/java/com/android/internal/telephony/sip/SipCommandInterface.java b/src/java/com/android/internal/telephony/sip/SipCommandInterface.java
index 396fd4b..057813a 100644
--- a/src/java/com/android/internal/telephony/sip/SipCommandInterface.java
+++ b/src/java/com/android/internal/telephony/sip/SipCommandInterface.java
@@ -241,6 +241,10 @@ class SipCommandInterface extends BaseCommands implements CommandsInterface {
     }
 
     @Override
+    public void sendCdmaSms(byte[] pdu, Message result, boolean isExpectMore) {
+    }
+
+    @Override
     public void sendImsGsmSms (String smscPDU, String pdu,
             int retry, int messageRef, Message response) {
     }
diff --git a/src/java/com/android/internal/telephony/test/SimulatedCommands.java b/src/java/com/android/internal/telephony/test/SimulatedCommands.java
index 1fc9a26..dca4f6f 100644
--- a/src/java/com/android/internal/telephony/test/SimulatedCommands.java
+++ b/src/java/com/android/internal/telephony/test/SimulatedCommands.java
@@ -146,6 +146,7 @@ public class SimulatedCommands extends BaseCommands
     private boolean mDcSuccess = true;
     private SetupDataCallResult mSetupDataCallResult;
     private boolean mIsRadioPowerFailResponse = false;
+    private String smscAddress;
 
     //***** Constructor
     public
@@ -1051,6 +1052,7 @@ public class SimulatedCommands extends BaseCommands
      */
     @Override
     public void startDtmf(char c, Message result) {
+        SimulatedCommandsVerifier.getInstance().startDtmf(c, result);
         resultSuccess(result, null);
     }
 
@@ -1212,12 +1214,15 @@ public class SimulatedCommands extends BaseCommands
 
     @Override
     public void getSmscAddress(Message result) {
-        unimplemented(result);
+        resultSuccess(result, smscAddress);
+        SimulatedCommandsVerifier.getInstance().getSmscAddress(result);
     }
 
     @Override
     public void setSmscAddress(String address, Message result) {
-        unimplemented(result);
+        smscAddress = address;
+        resultSuccess(result, null);
+        SimulatedCommandsVerifier.getInstance().setSmscAddress(address, result);
     }
 
     @Override
@@ -1788,6 +1793,13 @@ public class SimulatedCommands extends BaseCommands
         resultSuccess(response, null);
     }
 
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void sendCdmaSms(byte[] pdu, Message response, boolean  expectMore){
+    }
+
     @Override
     public void setCdmaBroadcastActivation(boolean activate, Message response) {
         unimplemented(response);
diff --git a/src/java/com/android/internal/telephony/test/SimulatedCommandsVerifier.java b/src/java/com/android/internal/telephony/test/SimulatedCommandsVerifier.java
index f43cee0..09fdbbb 100644
--- a/src/java/com/android/internal/telephony/test/SimulatedCommandsVerifier.java
+++ b/src/java/com/android/internal/telephony/test/SimulatedCommandsVerifier.java
@@ -839,6 +839,11 @@ public class SimulatedCommandsVerifier implements CommandsInterface {
     }
 
     @Override
+    public void sendCdmaSms(byte[] pdu, Message response, boolean expectMore) {
+
+    }
+
+    @Override
     public void sendImsGsmSms(String smscPDU, String pdu, int retry, int messageRef,
                               Message response) {
 
@@ -1308,8 +1313,7 @@ public class SimulatedCommandsVerifier implements CommandsInterface {
     }
 
     @Override
-    public void setUiccSubscription(int slotId, int appIndex, int subId, int subStatus,
-                                    Message result) {
+    public void setUiccSubscription(int appIndex, boolean activate, Message result) {
 
     }
 
diff --git a/src/java/com/android/internal/telephony/uicc/AdnRecord.java b/src/java/com/android/internal/telephony/uicc/AdnRecord.java
index 717ec31..293d05d 100755
--- a/src/java/com/android/internal/telephony/uicc/AdnRecord.java
+++ b/src/java/com/android/internal/telephony/uicc/AdnRecord.java
@@ -323,7 +323,7 @@ public class AdnRecord implements Parcelable {
             return null;
         }
 
-        byteTag = !TextUtils.isEmpty(mAlphaTag) ? GsmAlphabet.stringToGsm8BitPacked(mAlphaTag)
+        byteTag = !TextUtils.isEmpty(mAlphaTag) ? IccUtils.stringToAdnStringField(mAlphaTag)
                 : new byte[0];
 
         if (byteTag.length > footerOffset) {
diff --git a/src/java/com/android/internal/telephony/uicc/CsimFileHandler.java b/src/java/com/android/internal/telephony/uicc/CsimFileHandler.java
index e45afa9..659af39 100644
--- a/src/java/com/android/internal/telephony/uicc/CsimFileHandler.java
+++ b/src/java/com/android/internal/telephony/uicc/CsimFileHandler.java
@@ -44,8 +44,13 @@ public final class CsimFileHandler extends IccFileHandler implements IccConstant
         case EF_CSIM_IMSIM:
         case EF_CSIM_CDMAHOME:
         case EF_CSIM_EPRL:
+        case EF_CSIM_PRL:
         case EF_CSIM_MIPUPP:
+        case EF_RUIM_ID:
             return MF_SIM + DF_ADF;
+        case EF_CSIM_MSPL:
+        case EF_CSIM_MLPL:
+            return MF_SIM + DF_TELECOM + DF_MMSS;
         }
         String path = getCommonIccEFPath(efid);
         if (path == null) {
diff --git a/src/java/com/android/internal/telephony/uicc/IccCardApplicationStatus.java b/src/java/com/android/internal/telephony/uicc/IccCardApplicationStatus.java
index f1b0e43..8bf820f 100644
--- a/src/java/com/android/internal/telephony/uicc/IccCardApplicationStatus.java
+++ b/src/java/com/android/internal/telephony/uicc/IccCardApplicationStatus.java
@@ -92,7 +92,31 @@ public class IccCardApplicationStatus {
         PERSOSUBSTATE_RUIM_HRPD_PUK,
         PERSOSUBSTATE_RUIM_CORPORATE_PUK,
         PERSOSUBSTATE_RUIM_SERVICE_PROVIDER_PUK,
-        PERSOSUBSTATE_RUIM_RUIM_PUK;
+        PERSOSUBSTATE_RUIM_RUIM_PUK,
+        PERSOSUBSTATE_SIM_SPN(100),
+        PERSOSUBSTATE_SIM_SPN_PUK(101),
+        PERSOSUBSTATE_SIM_SP_EHPLMN(102),
+        PERSOSUBSTATE_SIM_SP_EHPLMN_PUK(103),
+        PERSOSUBSTATE_SIM_ICCID(104),
+        PERSOSUBSTATE_SIM_ICCID_PUK(105),
+        PERSOSUBSTATE_SIM_IMPI(106),
+        PERSOSUBSTATE_SIM_IMPI_PUK(107),
+        PERSOSUBSTATE_SIM_NS_SP(108),
+        PERSOSUBSTATE_SIM_NS_SP_PUK(109);
+
+        private int State;
+
+        PersoSubState(int state) {
+            this.State = state;
+        }
+
+        PersoSubState() {
+            this.State = this.ordinal();
+        }
+
+        public int getState() {
+            return this.State;
+        }
 
         boolean isPersoSubStateUnknown() {
             return this == PERSOSUBSTATE_UNKNOWN;
@@ -175,6 +199,17 @@ public class IccCardApplicationStatus {
             case 22: newSubState = PersoSubState.PERSOSUBSTATE_RUIM_CORPORATE_PUK; break;
             case 23: newSubState = PersoSubState.PERSOSUBSTATE_RUIM_SERVICE_PROVIDER_PUK; break;
             case 24: newSubState = PersoSubState.PERSOSUBSTATE_RUIM_RUIM_PUK; break;
+
+            case 100: newSubState = PersoSubState.PERSOSUBSTATE_SIM_SPN; break;
+            case 101: newSubState = PersoSubState.PERSOSUBSTATE_SIM_SPN_PUK; break;
+            case 102: newSubState = PersoSubState.PERSOSUBSTATE_SIM_SP_EHPLMN; break;
+            case 103: newSubState = PersoSubState.PERSOSUBSTATE_SIM_SP_EHPLMN_PUK; break;
+            case 104: newSubState = PersoSubState.PERSOSUBSTATE_SIM_ICCID; break;
+            case 105: newSubState = PersoSubState.PERSOSUBSTATE_SIM_ICCID_PUK; break;
+            case 106: newSubState = PersoSubState.PERSOSUBSTATE_SIM_IMPI; break;
+            case 107: newSubState = PersoSubState.PERSOSUBSTATE_SIM_IMPI_PUK; break;
+            case 108: newSubState = PersoSubState.PERSOSUBSTATE_SIM_NS_SP; break;
+            case 109: newSubState = PersoSubState.PERSOSUBSTATE_SIM_NS_SP_PUK; break;
             default:
                 newSubState = PersoSubState.PERSOSUBSTATE_UNKNOWN;
                 loge("PersoSubstateFromRILInt: bad substate: " + substate
diff --git a/src/java/com/android/internal/telephony/uicc/IccConstants.java b/src/java/com/android/internal/telephony/uicc/IccConstants.java
index 0f41f1e..3479412 100644
--- a/src/java/com/android/internal/telephony/uicc/IccConstants.java
+++ b/src/java/com/android/internal/telephony/uicc/IccConstants.java
@@ -62,6 +62,7 @@ public interface IccConstants {
     // CDMA RUIM file ids from 3GPP2 C.S0023-0
     static final int EF_CST = 0x6F32;
     static final int EF_RUIM_SPN =0x6F41;
+    static final int EF_RUIM_ID = 0x6F31;
 
     // ETSI TS.102.221
     static final int EF_PL = 0x2F05;
@@ -72,6 +73,10 @@ public interface IccConstants {
     static final int EF_CSIM_IMSIM = 0x6F22;
     static final int EF_CSIM_CDMAHOME = 0x6F28;
     static final int EF_CSIM_EPRL = 0x6F5A;
+    static final int EF_CSIM_PRL = 0x6F30;
+    // C.S0074-Av1.0 Section 4
+    static final int EF_CSIM_MLPL = 0x4F20;
+    static final int EF_CSIM_MSPL = 0x4F21;
     static final int EF_CSIM_MIPUPP = 0x6F4D;
 
     //ISIM access
@@ -103,6 +108,7 @@ public interface IccConstants {
     static final String DF_GRAPHICS = "5F50";
     static final String DF_GSM = "7F20";
     static final String DF_CDMA = "7F25";
+    static final String DF_MMSS = "5F3C";
 
     //UICC access
     static final String DF_ADF = "7FFF";
diff --git a/src/java/com/android/internal/telephony/uicc/IccRecords.java b/src/java/com/android/internal/telephony/uicc/IccRecords.java
index 01ffeb1..dde305e 100644
--- a/src/java/com/android/internal/telephony/uicc/IccRecords.java
+++ b/src/java/com/android/internal/telephony/uicc/IccRecords.java
@@ -100,6 +100,8 @@ public abstract class IccRecords extends Handler implements IccConstants {
 
     private String mSpn;
 
+    protected int mSmsCountOnIcc = -1;
+
     protected String mGid1;
     protected String mGid2;
 
@@ -144,6 +146,7 @@ public abstract class IccRecords extends Handler implements IccConstants {
     public static final int EVENT_REFRESH = 31; // ICC refresh occurred
     protected static final int EVENT_APP_READY = 1;
     private static final int EVENT_AKA_AUTHENTICATE_DONE          = 90;
+    protected static final int EVENT_GET_SMS_RECORD_SIZE_DONE = 28;
 
     public static final int CALL_FORWARDING_STATUS_DISABLED = 0;
     public static final int CALL_FORWARDING_STATUS_ENABLED = 1;
@@ -692,6 +695,28 @@ public abstract class IccRecords extends Handler implements IccConstants {
                 }
 
                 break;
+            case EVENT_GET_SMS_RECORD_SIZE_DONE:
+                ar = (AsyncResult) msg.obj;
+
+                if (ar.exception != null) {
+                    loge("Exception in EVENT_GET_SMS_RECORD_SIZE_DONE " + ar.exception);
+                    break;
+                }
+
+                int[] recordSize = (int[])ar.result;
+                try {
+                    // recordSize[0]  is the record length
+                    // recordSize[1]  is the total length of the EF file
+                    // recordSize[2]  is the number of records in the EF file
+                    mSmsCountOnIcc = recordSize[2];
+                    log("EVENT_GET_SMS_RECORD_SIZE_DONE Size " + recordSize[0]
+                            + " total " + recordSize[1]
+                                    + " record " + recordSize[2]);
+                } catch (ArrayIndexOutOfBoundsException exc) {
+                    loge("ArrayIndexOutOfBoundsException in EVENT_GET_SMS_RECORD_SIZE_DONE: "
+                            + exc.toString());
+                }
+                break;
 
             default:
                 super.handleMessage(msg);
@@ -926,6 +951,14 @@ public abstract class IccRecords extends Handler implements IccConstants {
         return android.util.Base64.encodeToString(auth_rsp.payload, android.util.Base64.NO_WRAP);
     }
 
+    /**
+     * To get SMS capacity count on ICC card.
+     */
+    public int getSmsCapacityOnIcc() {
+        if (DBG) log("getSmsCapacityOnIcc: " + mSmsCountOnIcc);
+        return mSmsCountOnIcc;
+    }
+
     public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
         pw.println("IccRecords: " + this);
         pw.println(" mDestroyed=" + mDestroyed);
diff --git a/src/java/com/android/internal/telephony/uicc/RuimFileHandler.java b/src/java/com/android/internal/telephony/uicc/RuimFileHandler.java
index 58e939f..1f10304 100644
--- a/src/java/com/android/internal/telephony/uicc/RuimFileHandler.java
+++ b/src/java/com/android/internal/telephony/uicc/RuimFileHandler.java
@@ -64,8 +64,13 @@ public final class RuimFileHandler extends IccFileHandler {
         case EF_CSIM_IMSIM:
         case EF_CSIM_CDMAHOME:
         case EF_CSIM_EPRL:
+        case EF_CSIM_PRL:
         case EF_CSIM_MIPUPP:
+        case EF_RUIM_ID:
             return MF_SIM + DF_CDMA;
+        case EF_CSIM_MSPL:
+        case EF_CSIM_MLPL:
+            return MF_SIM + DF_TELECOM + DF_MMSS;
         }
         return getCommonIccEFPath(efid);
     }
diff --git a/src/java/com/android/internal/telephony/uicc/RuimRecords.java b/src/java/com/android/internal/telephony/uicc/RuimRecords.java
index 9a9435a..8b9c113 100644
--- a/src/java/com/android/internal/telephony/uicc/RuimRecords.java
+++ b/src/java/com/android/internal/telephony/uicc/RuimRecords.java
@@ -283,7 +283,7 @@ public class RuimRecords extends IccRecords {
             return imsi.substring(0, 3 + mMncLength);
         }
 
-        return mImsi.substring(0, 3 + CSIM_IMSI_MNC_LENGTH);
+        return imsi.substring(0, 3 + CSIM_IMSI_MNC_LENGTH);
     }
 
     // Refer to ETSI TS 102.221
@@ -435,7 +435,7 @@ public class RuimRecords extends IccRecords {
                 mMin = null;
                 return;
             }
-            if (VDBG) log("CSIM_IMSIM=" + IccUtils.bytesToHexString(data));
+            if (DBG) log("CSIM_IMSIM=" + IccUtils.bytesToHexString(data));
 
             // C.S0065 section 5.2.2 for IMSI_M encoding
             // C.S0005 section 2.3.1 for MIN encoding in IMSI_M.
@@ -446,7 +446,7 @@ public class RuimRecords extends IccRecords {
                 if (null != mImsi) {
                     mMin = mImsi.substring(5, 15);
                 }
-                if (DBG) log("IMSI: " + mImsi.substring(0, 5) + "xxxxxxxxx");
+                log("IMSI: " + mImsi.substring(0, 5) + "xxxxxxxxx");
 
             } else {
                 if (DBG) log("IMSI not provisioned in card");
@@ -462,7 +462,7 @@ public class RuimRecords extends IccRecords {
 
             mImsiReadyRegistrants.notifyRegistrants();
         }
-    }
+   }
 
     private class EfCsimCdmaHomeLoaded implements IccRecordLoaded {
         @Override
@@ -902,6 +902,7 @@ public class RuimRecords extends IccRecords {
         mFh.loadEFTransparent(EF_CSIM_MIPUPP,
                 obtainMessage(EVENT_GET_ICC_RECORD_DONE, new EfCsimMipUppLoaded()));
         mRecordsToLoad++;
+        mFh.getEFLinearRecordSize(EF_SMS, obtainMessage(EVENT_GET_SMS_RECORD_SIZE_DONE));
 
         if (DBG) log("fetchRuimRecords " + mRecordsToLoad + " requested: " + mRecordsRequested);
         // Further records that can be inserted are Operator/OEM dependent
diff --git a/src/java/com/android/internal/telephony/uicc/SIMRecords.java b/src/java/com/android/internal/telephony/uicc/SIMRecords.java
index 1075146..d1859ad 100755
--- a/src/java/com/android/internal/telephony/uicc/SIMRecords.java
+++ b/src/java/com/android/internal/telephony/uicc/SIMRecords.java
@@ -1720,6 +1720,7 @@ public class SIMRecords extends IccRecords {
         mRecordsToLoad++;
 
         loadEfLiAndEfPl();
+        mFh.getEFLinearRecordSize(EF_SMS, obtainMessage(EVENT_GET_SMS_RECORD_SIZE_DONE));
 
         // XXX should seek instead of examining them all
         if (false) { // XXX
diff --git a/src/java/com/android/internal/telephony/uicc/UiccCardApplication.java b/src/java/com/android/internal/telephony/uicc/UiccCardApplication.java
index 7a361e3..cf2aac3 100644
--- a/src/java/com/android/internal/telephony/uicc/UiccCardApplication.java
+++ b/src/java/com/android/internal/telephony/uicc/UiccCardApplication.java
@@ -149,7 +149,7 @@ public class UiccCardApplication {
             }
 
             if (mPersoSubState != oldPersoSubState &&
-                    mPersoSubState == PersoSubState.PERSOSUBSTATE_SIM_NETWORK) {
+                    isPersoLocked()) {
                 notifyNetworkLockedRegistrantsIfNeeded(null);
             }
 
@@ -532,13 +532,14 @@ public class UiccCardApplication {
         }
 
         if (mAppState == AppState.APPSTATE_SUBSCRIPTION_PERSO &&
-                mPersoSubState == PersoSubState.PERSOSUBSTATE_SIM_NETWORK) {
+                isPersoLocked()) {
+            AsyncResult ar = new AsyncResult(null, mPersoSubState.ordinal(), null);
             if (r == null) {
                 if (DBG) log("Notifying registrants: NETWORK_LOCKED");
-                mNetworkLockedRegistrants.notifyRegistrants();
+                mNetworkLockedRegistrants.notifyRegistrants(ar);
             } else {
                 if (DBG) log("Notifying 1 registrant: NETWORK_LOCED");
-                r.notifyRegistrant(new AsyncResult(null, null, null));
+                r.notifyRegistrant(ar);
             }
         }
     }
@@ -625,6 +626,17 @@ public class UiccCardApplication {
         }
     }
 
+    public boolean isPersoLocked() {
+        switch (mPersoSubState) {
+            case PERSOSUBSTATE_UNKNOWN:
+            case PERSOSUBSTATE_IN_PROGRESS:
+            case PERSOSUBSTATE_READY:
+                return false;
+            default:
+                return true;
+        }
+    }
+
     /**
      * Supply the ICC PIN to the ICC
      *
diff --git a/src/java/com/android/internal/telephony/uicc/UiccController.java b/src/java/com/android/internal/telephony/uicc/UiccController.java
index 670b85a..05b3d2a 100644
--- a/src/java/com/android/internal/telephony/uicc/UiccController.java
+++ b/src/java/com/android/internal/telephony/uicc/UiccController.java
@@ -166,16 +166,7 @@ public class UiccController extends Handler {
         for (int i = 0; i < mCis.length; i++) {
             mCis[i].registerForIccStatusChanged(this, EVENT_ICC_STATUS_CHANGED, i);
 
-            // TODO remove this once modem correctly notifies the unsols
-            // If the device is unencrypted or has been decrypted or FBE is supported,
-            // i.e. not in CryptKeeper bounce, read SIM when radio state is available.
-            // Else wait for radio to be on. This is needed for the scenario when SIM is locked --
-            // to avoid overlap of CryptKeeper and SIM unlock screen.
-            if (!StorageManager.inCryptKeeperBounce()) {
-                mCis[i].registerForAvailable(this, EVENT_RADIO_AVAILABLE, i);
-            } else {
-                mCis[i].registerForOn(this, EVENT_RADIO_ON, i);
-            }
+            mCis[i].registerForAvailable(this, EVENT_RADIO_AVAILABLE, i);
             mCis[i].registerForNotAvailable(this, EVENT_RADIO_UNAVAILABLE, i);
             mCis[i].registerForIccRefresh(this, EVENT_SIM_REFRESH, i);
         }
diff --git a/src/java/com/android/internal/telephony/uicc/UiccProfile.java b/src/java/com/android/internal/telephony/uicc/UiccProfile.java
index 2910ff7..69540c0 100644
--- a/src/java/com/android/internal/telephony/uicc/UiccProfile.java
+++ b/src/java/com/android/internal/telephony/uicc/UiccProfile.java
@@ -55,6 +55,7 @@ import com.android.internal.telephony.MccTable;
 import com.android.internal.telephony.Phone;
 import com.android.internal.telephony.PhoneConstants;
 import com.android.internal.telephony.PhoneFactory;
+import com.android.internal.telephony.RIL;
 import com.android.internal.telephony.SubscriptionController;
 import com.android.internal.telephony.cat.CatService;
 import com.android.internal.telephony.uicc.IccCardApplicationStatus.AppType;
@@ -103,6 +104,7 @@ public class UiccProfile extends IccCard {
     private final UiccCard mUiccCard; //parent
     private CatService mCatService;
     private UiccCarrierPrivilegeRules mCarrierPrivilegeRules;
+    private boolean mDefaultAppsActivated;
     private boolean mDisposed = false;
 
     private RegistrantList mCarrierPrivilegeRegistrants = new RegistrantList();
@@ -174,7 +176,8 @@ public class UiccProfile extends IccCard {
             loglocal("handleMessage: Received " + msg.what + " for phoneId " + mPhoneId);
             switch (msg.what) {
                 case EVENT_NETWORK_LOCKED:
-                    mNetworkLockedRegistrants.notifyRegistrants();
+                    mNetworkLockedRegistrants.notifyRegistrants(
+                            new AsyncResult(null, mUiccApplication.getPersoSubState().ordinal(), null));
                     // intentional fall through
                 case EVENT_RADIO_OFF_OR_UNAVAILABLE:
                 case EVENT_ICC_LOCKED:
@@ -304,9 +307,7 @@ public class UiccProfile extends IccCard {
     private void setCurrentAppType(boolean isGsm) {
         if (VDBG) log("setCurrentAppType");
         synchronized (mLock) {
-            boolean isLteOnCdmaMode = TelephonyManager.getLteOnCdmaModeStatic()
-                    == PhoneConstants.LTE_ON_CDMA_TRUE;
-            if (isGsm || isLteOnCdmaMode) {
+            if (isGsm) {
                 mCurrentAppType = UiccController.APP_FAM_3GPP;
             } else {
                 mCurrentAppType = UiccController.APP_FAM_3GPP2;
@@ -457,8 +458,7 @@ public class UiccProfile extends IccCard {
                 cardLocked = true;
                 lockedState = IccCardConstants.State.PUK_REQUIRED;
             } else if (appState == IccCardApplicationStatus.AppState.APPSTATE_SUBSCRIPTION_PERSO) {
-                if (mUiccApplication.getPersoSubState()
-                        == IccCardApplicationStatus.PersoSubState.PERSOSUBSTATE_SIM_NETWORK) {
+                if (mUiccApplication.isPersoLocked()) {
                     if (VDBG) log("updateExternalState: PERSOSUBSTATE_SIM_NETWORK");
                     cardLocked = true;
                     lockedState = IccCardConstants.State.NETWORK_LOCKED;
@@ -505,24 +505,16 @@ public class UiccProfile extends IccCard {
                 break;
             case APPSTATE_READY:
                 checkAndUpdateIfAnyAppToBeIgnored();
-                if (areAllApplicationsReady()) {
-                    if (areAllRecordsLoaded() && areCarrierPriviligeRulesLoaded()) {
-                        if (VDBG) log("updateExternalState: setting state to LOADED");
-                        setExternalState(IccCardConstants.State.LOADED);
-                    } else {
-                        if (VDBG) {
-                            log("updateExternalState: setting state to READY; records loaded "
-                                    + areAllRecordsLoaded() + ", carrier privilige rules loaded "
-                                    + areCarrierPriviligeRulesLoaded());
-                        }
-                        setExternalState(IccCardConstants.State.READY);
-                    }
+                if (areReadyAppsRecordsLoaded() && areCarrierPriviligeRulesLoaded()) {
+                    if (VDBG) log("updateExternalState: setting state to LOADED");
+                    setExternalState(IccCardConstants.State.LOADED);
                 } else {
                     if (VDBG) {
-                        log("updateExternalState: app state is READY but not for all apps; "
-                                + "setting state to NOT_READY");
+                        log("updateExternalState: setting state to READY; records loaded "
+                            + areReadyAppsRecordsLoaded() + ", carrier privilige rules loaded "
+                            + areCarrierPriviligeRulesLoaded());
                     }
-                    setExternalState(IccCardConstants.State.NOT_READY);
+                        setExternalState(IccCardConstants.State.READY);
                 }
                 break;
         }
@@ -687,7 +679,8 @@ public class UiccProfile extends IccCard {
             mNetworkLockedRegistrants.add(r);
 
             if (getState() == IccCardConstants.State.NETWORK_LOCKED) {
-                r.notifyRegistrant();
+                r.notifyRegistrant(new AsyncResult(null, mUiccApplication.getPersoSubState()
+                        .ordinal(), null));
             }
         }
     }
@@ -920,10 +913,59 @@ public class UiccProfile extends IccCard {
             }
 
             sanitizeApplicationIndexesLocked();
+
+            if (needsSimActivation()) {
+                if (ics.mCardState == CardState.CARDSTATE_PRESENT) {
+                    if (!mDefaultAppsActivated) {
+                        activateDefaultApps();
+                        mDefaultAppsActivated = true;
+                    }
+                } else {
+                    // SIM removed, reset activation flag to make sure
+                    // to re-run the activation at the next insertion
+                    mDefaultAppsActivated = false;
+                }
+            }
+
             updateIccAvailability(true);
         }
     }
 
+    private boolean needsSimActivation() {
+        if (mCi instanceof RIL) {
+            return ((RIL) mCi).needsOldRilFeature("simactivation");
+        }
+        return false;
+    }
+
+    private void activateDefaultApps() {
+        int gsmIndex = mGsmUmtsSubscriptionAppIndex;
+        int cdmaIndex = mCdmaSubscriptionAppIndex;
+
+        if (gsmIndex < 0 || cdmaIndex < 0) {
+            for (int i = 0; i < mUiccApplications.length; i++) {
+                if (mUiccApplications[i] == null) {
+                    continue;
+                }
+
+                AppType appType = mUiccApplications[i].getType();
+                if (gsmIndex < 0 &&
+                        (appType == AppType.APPTYPE_USIM || appType == AppType.APPTYPE_SIM)) {
+                    gsmIndex = i;
+                } else if (cdmaIndex < 0 &&
+                        (appType == AppType.APPTYPE_CSIM || appType == AppType.APPTYPE_RUIM)) {
+                    cdmaIndex = i;
+                }
+            }
+        }
+        if (gsmIndex >= 0) {
+            mCi.setUiccSubscription(gsmIndex, true, null);
+        }
+        if (cdmaIndex >= 0) {
+            mCi.setUiccSubscription(cdmaIndex, true, null);
+        }
+    }
+
     private void createAndUpdateCatServiceLocked() {
         if (mUiccApplications.length > 0 && mUiccApplications[0] != null) {
             // Initialize or Reinitialize CatService
@@ -996,33 +1038,18 @@ public class UiccProfile extends IccCard {
         }
     }
 
-    private boolean areAllApplicationsReady() {
-        for (UiccCardApplication app : mUiccApplications) {
-            if (app != null && isSupportedApplication(app) && !app.isReady()
-                    && !app.isAppIgnored()) {
-                if (VDBG) log("areAllApplicationsReady: return false");
-                return false;
-            }
-        }
-
-        if (VDBG) {
-            log("areAllApplicationsReady: outside loop, return " + (mUiccApplication != null));
-        }
-        return mUiccApplication != null;
-    }
-
-    private boolean areAllRecordsLoaded() {
+    private boolean areReadyAppsRecordsLoaded() {
         for (UiccCardApplication app : mUiccApplications) {
-            if (app != null && isSupportedApplication(app) && !app.isAppIgnored()) {
+            if (app != null && isSupportedApplication(app) && app.isReady() && !app.isAppIgnored()) {
                 IccRecords ir = app.getIccRecords();
                 if (ir == null || !ir.isLoaded()) {
-                    if (VDBG) log("areAllRecordsLoaded: return false");
+                    if (VDBG) log("areReadyAppsRecordsLoaded: return false");
                     return false;
                 }
             }
         }
         if (VDBG) {
-            log("areAllRecordsLoaded: outside loop, return " + (mUiccApplication != null));
+            log("areReadyAppsRecordsLoaded: outside loop, return " + (mUiccApplication != null));
         }
         return mUiccApplication != null;
     }
diff --git a/src/java/com/google/android/mms/pdu/PduComposer.java b/src/java/com/google/android/mms/pdu/PduComposer.java
index bb44bab..582caec 100644
--- a/src/java/com/google/android/mms/pdu/PduComposer.java
+++ b/src/java/com/google/android/mms/pdu/PduComposer.java
@@ -155,7 +155,8 @@ public class PduComposer {
         /* make the message */
         switch (type) {
             case PduHeaders.MESSAGE_TYPE_SEND_REQ:
-                if (makeSendReqPdu() != PDU_COMPOSE_SUCCESS) {
+            case PduHeaders.MESSAGE_TYPE_RETRIEVE_CONF:
+                if (makeSendRetrievePdu(type) != PDU_COMPOSE_SUCCESS) {
                     return null;
                 }
                 break;
@@ -564,6 +565,7 @@ public class PduComposer {
             case PduHeaders.PRIORITY:
             case PduHeaders.DELIVERY_REPORT:
             case PduHeaders.READ_REPORT:
+            case PduHeaders.RETRIEVE_STATUS:
                 int octet = mPduHeader.getOctet(field);
                 if (0 == octet) {
                     return PDU_COMPOSE_FIELD_NOT_SET;
@@ -584,6 +586,7 @@ public class PduComposer {
                 break;
 
             case PduHeaders.SUBJECT:
+            case PduHeaders.RETRIEVE_TEXT:
                 EncodedStringValue enString =
                     mPduHeader.getEncodedStringValue(field);
                 if (null == enString) {
@@ -757,7 +760,7 @@ public class PduComposer {
     /**
      * Make Send.req.
      */
-    private int makeSendReqPdu() {
+    private int makeSendRetrievePdu(int type) {
         if (mMessage == null) {
             mMessage = new ByteArrayOutputStream();
             mPosition = 0;
@@ -765,7 +768,7 @@ public class PduComposer {
 
         // X-Mms-Message-Type
         appendOctet(PduHeaders.MESSAGE_TYPE);
-        appendOctet(PduHeaders.MESSAGE_TYPE_SEND_REQ);
+        appendOctet(type);
 
         // X-Mms-Transaction-ID
         appendOctet(PduHeaders.TRANSACTION_ID);
@@ -831,17 +834,25 @@ public class PduComposer {
         // X-Mms-Read-Report Optional
         appendHeader(PduHeaders.READ_REPORT);
 
+        if (type == PduHeaders.MESSAGE_TYPE_RETRIEVE_CONF) {
+            // X-Mms-Retrieve-Status Optional
+            appendHeader(PduHeaders.RETRIEVE_STATUS);
+            // X-Mms-Retrieve-Text Optional
+            appendHeader(PduHeaders.RETRIEVE_TEXT);
+        }
+
+
         //    Content-Type
         appendOctet(PduHeaders.CONTENT_TYPE);
 
         //  Message body
-        return makeMessageBody();
+        return makeMessageBody(type);
     }
 
     /**
      * Make message body.
      */
-    private int makeMessageBody() {
+    private int makeMessageBody(int type) {
         // 1. add body informations
         mStack.newbuf();  // Switching buffer because we need to
 
@@ -858,7 +869,12 @@ public class PduComposer {
         appendShortInteger(contentTypeIdentifier.intValue());
 
         // content-type parameter: start
-        PduBody body = ((SendReq) mPdu).getBody();
+        PduBody body;
+        if (type == PduHeaders.MESSAGE_TYPE_RETRIEVE_CONF) {
+            body = ((RetrieveConf) mPdu).getBody();
+        } else {
+            body = ((SendReq) mPdu).getBody();
+        }
         if (null == body || body.getPartsNum() == 0) {
             // empty message
             appendUintvarInteger(0);
diff --git a/tests/telephonytests/src/com/android/internal/telephony/ContextFixture.java b/tests/telephonytests/src/com/android/internal/telephony/ContextFixture.java
index 1d08c42..c8a3bcd 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/ContextFixture.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/ContextFixture.java
@@ -178,6 +178,17 @@ public class ContextFixture implements TestFixture<Context> {
         }
 
         @Override
+        public void startActivity(Intent intent) {
+            logd("startActivity called for " + intent);
+        }
+
+        @Override
+        public ComponentName startService(Intent intent) {
+            logd("startService for intent " + intent);
+            return null;
+        }
+
+        @Override
         public boolean bindService(
                 Intent serviceIntent,
                 ServiceConnection connection,
diff --git a/tests/telephonytests/src/com/android/internal/telephony/GsmCdmaConnectionTest.java b/tests/telephonytests/src/com/android/internal/telephony/GsmCdmaConnectionTest.java
index 1a4d619..6ff3031 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/GsmCdmaConnectionTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/GsmCdmaConnectionTest.java
@@ -71,6 +71,19 @@ public class GsmCdmaConnectionTest extends TelephonyTest {
     }
 
     @Test @SmallTest
+    public void testOriginalDialString(){
+        doReturn(PhoneConstants.PHONE_TYPE_CDMA).when(mPhone).getPhoneType();
+        connection = new GsmCdmaConnection(mPhone, "+8610000", mCT, null,
+                false /*isEmergencyCall*/);
+        assertEquals("+8610000", connection.getOrigDialString());
+
+        doReturn(PhoneConstants.PHONE_TYPE_GSM).when(mPhone).getPhoneType();
+        connection = new GsmCdmaConnection(mPhone, "+8610000", mCT, null,
+                false /*isEmergencyCall*/);
+        assertEquals("+8610000", connection.getOrigDialString());
+    }
+
+    @Test @SmallTest
     public void testSanityGSM() {
         connection = new GsmCdmaConnection(mPhone, String.format(
                 "+1 (700).555-41NN%c1234", PhoneNumberUtils.PAUSE), mCT, null,
@@ -103,7 +116,7 @@ public class GsmCdmaConnectionTest extends TelephonyTest {
         assertFalse(connection.isMultiparty());
         assertNotNull(connection.getRemainingPostDialString());
         /* CDMA phone type dont have origDialString */
-        assertNull(connection.getOrigDialString());
+        assertEquals("+1 (700).555-41NN,1234", connection.getOrigDialString());
     }
 
     @Test @SmallTest
diff --git a/tests/telephonytests/src/com/android/internal/telephony/GsmCdmaPhoneTest.java b/tests/telephonytests/src/com/android/internal/telephony/GsmCdmaPhoneTest.java
index 60bc61f..8051ab5 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/GsmCdmaPhoneTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/GsmCdmaPhoneTest.java
@@ -158,6 +158,7 @@ public class GsmCdmaPhoneTest extends TelephonyTest {
     @SmallTest
     public void testHandleActionCarrierConfigChanged() {
         Intent intent = new Intent(CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED);
+        intent.putExtra(PhoneConstants.PHONE_KEY, mPhoneUT.getPhoneId());
         mContext.sendBroadcast(intent);
         waitForMs(50);
         verify(mSST, times(1)).pollState();
@@ -564,7 +565,7 @@ public class GsmCdmaPhoneTest extends TelephonyTest {
         doReturn(imsi).when(mSimRecords).getIMSI();
         mPhoneUT.getCallForwardingOption(CF_REASON_UNCONDITIONAL, null);
         verify(mSimulatedCommandsVerifier).queryCallForwardStatus(
-                eq(CF_REASON_UNCONDITIONAL), eq(CommandsInterface.SERVICE_CLASS_VOICE),
+                eq(CF_REASON_UNCONDITIONAL), anyInt(),
                 nullable(String.class), nullable(Message.class));
         waitForMs(50);
         verify(mSimRecords).setVoiceCallForwardingFlag(anyInt(), anyBoolean(),
@@ -604,6 +605,17 @@ public class GsmCdmaPhoneTest extends TelephonyTest {
         verify(mSimRecords).setVoiceCallForwardingFlag(anyInt(), anyBoolean(), eq(cfNumber));
     }
 
+    @Test
+    public void testSetVideoCallForwardingPreference() {
+        mPhoneUT.setVideoCallForwardingPreference(false);
+        boolean cfPref = mPhoneUT.getVideoCallForwardingPreference();
+        assertFalse(cfPref);
+
+        mPhoneUT.setVideoCallForwardingPreference(true);
+        cfPref = mPhoneUT.getVideoCallForwardingPreference();
+        assertTrue(cfPref);
+    }
+
     /**
      * GsmCdmaPhone handles a lot of messages. This function verifies behavior for messages that are
      * received when obj is created and that are received on phone type switch
@@ -849,6 +861,7 @@ public class GsmCdmaPhoneTest extends TelephonyTest {
                 getSubIdUsingPhoneId(anyInt());
         assertEquals(false, mPhoneUT.getCallForwardingIndicator());
 
+        doReturn(true).when(mSubscriptionController).isActiveSubId(anyInt());
         // valid subId, sharedPreference not present
         int subId1 = 0;
         int subId2 = 1;
diff --git a/tests/telephonytests/src/com/android/internal/telephony/GsmSmsTest.java b/tests/telephonytests/src/com/android/internal/telephony/GsmSmsTest.java
index 06cd54f..ad5d0ab 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/GsmSmsTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/GsmSmsTest.java
@@ -48,6 +48,14 @@ public class GsmSmsTest extends AndroidTestCase {
     }
 
     @SmallTest
+    public void testRecipientAddress() throws Exception {
+        String pdu = "0891683108200505F011000D91683196032930F000000006C8329BFD0E01";
+        SmsMessage sms = SmsMessage.createFromPdu(HexDump.hexStringToByteArray(pdu));
+        assertEquals("+8613800250500", sms.getServiceCenterAddress());
+        assertEquals("+8613693092030", sms.getRecipientAddress());
+    }
+
+    @SmallTest
     public void testUdh() throws Exception {
         String pdu = "07914140279510F6440A8111110301003BF56080207130138A8C0B05040B8423F"
                 + "000032A02010106276170706C69636174696F6E2F766E642E7761702E6D6D732D"
diff --git a/tests/telephonytests/src/com/android/internal/telephony/SubscriptionControllerTest.java b/tests/telephonytests/src/com/android/internal/telephony/SubscriptionControllerTest.java
index ef9f7d4..ac41a27 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/SubscriptionControllerTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/SubscriptionControllerTest.java
@@ -382,7 +382,7 @@ public class SubscriptionControllerTest extends TelephonyTest {
 
         // Global settings should be all set.
         assertEquals(-1,  Settings.Global.getInt(mContext.getContentResolver(),
-                Settings.Global.ENHANCED_4G_MODE_ENABLED));
+                Settings.Global.ENHANCED_4G_MODE_ENABLED + subID));
 
         assertEquals(-1,  Settings.Global.getInt(mContext.getContentResolver(),
                 Settings.Global.VT_IMS_ENABLED));
diff --git a/tests/telephonytests/src/com/android/internal/telephony/SubscriptionInfoUpdaterTest.java b/tests/telephonytests/src/com/android/internal/telephony/SubscriptionInfoUpdaterTest.java
index a8bb8fb..36f829b 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/SubscriptionInfoUpdaterTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/SubscriptionInfoUpdaterTest.java
@@ -94,6 +94,9 @@ public class SubscriptionInfoUpdaterTest extends TelephonyTest {
     @Mock
     private IPackageManager mPackageManager;
 
+    @Mock
+    GsmCdmaPhone mSecondPhone;
+
     /*Custom ContentProvider */
     private class FakeSubscriptionContentProvider extends MockContentProvider {
         @Override
@@ -241,7 +244,7 @@ public class SubscriptionInfoUpdaterTest extends TelephonyTest {
         doReturn(null).when(mSubscriptionController)
                 .getSubInfoUsingSlotIndexPrivileged(eq(FAKE_SUB_ID_1), anyBoolean());
         doReturn("89012604200000000000").when(mIccRecord).getFullIccId();
-        doReturn(FAKE_MCC_MNC_1).when(mTelephonyManager).getSimOperatorNumeric(FAKE_SUB_ID_1);
+        doReturn(FAKE_MCC_MNC_1).when(mPhone).getOperatorNumeric();
 
         mUpdater.updateInternalIccState(
                 IccCardConstants.INTENT_VALUE_ICC_LOADED, null, FAKE_SUB_ID_1);
@@ -267,7 +270,7 @@ public class SubscriptionInfoUpdaterTest extends TelephonyTest {
                 stringArgumentCaptor.getAllValues().get(1)); */
 
         SubscriptionManager mSubscriptionManager = SubscriptionManager.from(mContext);
-        verify(mTelephonyManager).getSimOperatorNumeric(FAKE_SUB_ID_1);
+        verify(mPhone).getOperatorNumeric();
         verify(mSubscriptionManager, times(1)).addSubscriptionInfoRecord(
                 eq("89012604200000000000"), eq(FAKE_SUB_ID_1));
         verify(mSubscriptionController, times(1)).notifySubscriptionInfoChanged();
@@ -307,13 +310,13 @@ public class SubscriptionInfoUpdaterTest extends TelephonyTest {
                 .getSubInfoUsingSlotIndexPrivileged(eq(FAKE_SUB_ID_1), anyBoolean());
         doReturn("89012604200000000000").when(mIccRecord).getFullIccId();
         // operator numeric is empty
-        doReturn("").when(mTelephonyManager).getSimOperatorNumeric(FAKE_SUB_ID_1);
+        doReturn("").when(mPhone).getOperatorNumeric();
         mUpdater.updateInternalIccState(
                 IccCardConstants.INTENT_VALUE_ICC_LOADED, null, FAKE_SUB_ID_1);
 
         waitForMs(100);
         SubscriptionManager mSubscriptionManager = SubscriptionManager.from(mContext);
-        verify(mTelephonyManager).getSimOperatorNumeric(FAKE_SUB_ID_1);
+        verify(mPhone).getOperatorNumeric();
         verify(mSubscriptionManager, times(1)).addSubscriptionInfoRecord(
                 eq("89012604200000000000"), eq(FAKE_SUB_ID_1));
         verify(mSubscriptionController, times(1)).notifySubscriptionInfoChanged();
@@ -359,11 +362,14 @@ public class SubscriptionInfoUpdaterTest extends TelephonyTest {
     public void testDualSimLoaded() throws Exception {
         // Mock there is two sim cards
 
+        doReturn(mUiccProfile).when(mSecondPhone).getIccCard();
+        doReturn(mContext).when(mSecondPhone).getContext();
+
         replaceInstance(SubscriptionInfoUpdater.class, "mIccId", null,
                 new String[]{null, null});
         replaceInstance(SubscriptionInfoUpdater.class, "PROJECT_SIM_NUM", null, 2);
         replaceInstance(SubscriptionInfoUpdater.class, "mPhone", null,
-                new Phone[]{mPhone, mPhone});
+                new Phone[]{mPhone, mSecondPhone});
         replaceInstance(SubscriptionInfoUpdater.class, "mInsertSimState", null,
                 new int[]{SubscriptionInfoUpdater.SIM_NOT_CHANGE,
                         SubscriptionInfoUpdater.SIM_NOT_CHANGE});
@@ -377,8 +383,8 @@ public class SubscriptionInfoUpdaterTest extends TelephonyTest {
         doReturn(FAKE_SUB_ID_1).when(mSubscriptionController).getPhoneId(eq(FAKE_SUB_ID_1));
         doReturn(FAKE_SUB_ID_2).when(mSubscriptionController).getPhoneId(eq(FAKE_SUB_ID_2));
         doReturn(2).when(mTelephonyManager).getSimCount();
-        doReturn(FAKE_MCC_MNC_1).when(mTelephonyManager).getSimOperatorNumeric(eq(FAKE_SUB_ID_1));
-        doReturn(FAKE_MCC_MNC_2).when(mTelephonyManager).getSimOperatorNumeric(eq(FAKE_SUB_ID_2));
+        doReturn(FAKE_MCC_MNC_1).when(mPhone).getOperatorNumeric();
+        doReturn(FAKE_MCC_MNC_2).when(mSecondPhone).getOperatorNumeric();
         // Mock there is no sim inserted before
         doReturn(null).when(mSubscriptionController)
                 .getSubInfoUsingSlotIndexPrivileged(anyInt(), anyBoolean());
diff --git a/tests/telephonytests/src/com/android/internal/telephony/cat/CatServiceTest.java b/tests/telephonytests/src/com/android/internal/telephony/cat/CatServiceTest.java
new file mode 100644
index 0000000..e6fe61e
--- /dev/null
+++ b/tests/telephonytests/src/com/android/internal/telephony/cat/CatServiceTest.java
@@ -0,0 +1,211 @@
+/* Copyright (c) 2018, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+package com.android.internal.telephony;
+
+import android.content.Context;
+import android.content.Intent;
+import android.os.HandlerThread;
+import android.telephony.TelephonyManager;
+import android.test.suitebuilder.annotation.SmallTest;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import com.android.internal.telephony.cat.*;
+import com.android.internal.telephony.TelephonyTestUtils;
+import com.android.internal.telephony.uicc.IccFileHandler;
+import com.android.internal.telephony.uicc.UiccCard;
+import com.android.internal.telephony.uicc.UiccProfile;
+
+import org.mockito.ArgumentCaptor;
+import org.mockito.Mock;
+import org.mockito.Mockito;
+import org.mockito.MockitoAnnotations;
+import static org.junit.Assert.*;
+import static org.mockito.Mockito.doReturn;
+import static org.mockito.Mockito.mock;
+
+import java.lang.reflect.Method;
+import junit.framework.Assert;
+
+public class CatServiceTest extends TelephonyTest {
+
+    private static final int SINGLE_SIM = 1;
+
+    private TelephonyManager mTelephonyManager;
+    private CatService mCatService;
+
+    @Mock
+    private UiccProfile mMockUiccProfile;
+
+    @Mock
+    private IccFileHandler mIccFileHandler;
+
+
+    /* CatService extends handler and to instantiate the object within this test,
+     * we will need a looper to be ready. The HandlerThread here is used for this. The .start()
+     * is invoked in the setUp() call and the CatService is initialized in the
+     * onLooperPrepared() callback.
+     *
+     * This will not be required if the class under test is not extending Handler
+     */
+    private class CatServiceTestHandler extends HandlerThread {
+
+        private CatServiceTestHandler(String name) {
+            super(name);
+        }
+
+        @Override
+        public void onLooperPrepared() {
+            mCatService = CatService.getInstance(
+                mSimulatedCommands, mContext, mMockUiccProfile, 0);
+            setReady(true);
+        }
+    }
+
+    @Before
+    public void setUp() throws Exception {
+        super.setUp(this.getClass().getSimpleName());
+
+        mTelephonyManager = (TelephonyManager) mContext.getSystemService(
+            Context.TELEPHONY_SERVICE);
+
+        /* These are preconditions for the tests, all the APIs that the Class Under Test
+         * will invoke, has to be setup here using dummy values
+         */
+        doReturn(SINGLE_SIM).when(mTelephonyManager).getSimCount();
+        doReturn(SINGLE_SIM).when(mTelephonyManager).getPhoneCount();
+
+        /* Some of the objects are already provided by the base class and a subset of it
+         * which is required for the CatService test will be used as dummy responses
+         * when the Class Under Test will invoke it in its constructor or in the methods
+         * under test
+         */
+        doReturn(mUiccCardApplication3gpp).when(mMockUiccProfile).getApplicationIndex(0);
+        doReturn(mIccFileHandler).when(mUiccCardApplication3gpp).getIccFileHandler();
+        doReturn(mSimRecords).when(mUiccCardApplication3gpp).getIccRecords();
+
+        /* Kick off the handler thread, which leads to instantiation of the CatService object */
+        new CatServiceTestHandler(TAG).start();
+        waitUntilReady();
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        super.tearDown();
+        mTelephonyManager = null;
+        mCatService.dispose();
+    }
+
+    @Test @SmallTest
+    public void isSupportedSetupEventCommand() {
+        assertNotNull(mCatService);
+
+        /* Create a mock object to be sent to method under test */
+        CatCmdMessage mockCatMsg = mock(CatCmdMessage.class);
+
+        /* Create a real object that will returned when getSetEventList() is invoked
+         * on the mock object
+         */
+        CatCmdMessage.SetupEventListSettings eventListSettings =
+            mockCatMsg.new SetupEventListSettings();
+
+        /* Define the mock behavior for getSetEventList(), to return the real object created */
+        Mockito.when(mockCatMsg.getSetEventList()).thenReturn(eventListSettings);
+
+        eventListSettings.eventList =
+             new int[]{CatCmdMessage.SetupEventListConstants.LANGUAGE_SELECTION_EVENT};
+        assertEquals(true, callIsSupportedSetupEventCommand(mockCatMsg));
+    }
+
+    /* Wrapper function that uses reflection to invoke private methods */
+    private boolean callIsSupportedSetupEventCommand(CatCmdMessage mockCatMsg) {
+        Class clsParams[] = new Class[1];
+        clsParams[0] = CatCmdMessage.class;
+
+        Object params[] = new Object[1];
+        params[0] = mockCatMsg;
+
+        return (boolean)invokeNonStaticMethod(CatService.class, mCatService,
+                "isSupportedSetupEventCommand", clsParams, params);
+    }
+
+    /* In this test the method under test creates an intent,
+     * sets a flag and broadcasts it, this test ensures the flag is set
+     */
+    @Test
+    public void broadcastCatCmdIntent() {
+        CatCmdMessage mockCatMsg = mock(CatCmdMessage.class);
+
+        Class clsParams[] = new Class[1];
+        clsParams[0] = CatCmdMessage.class;
+
+        Object params[] = new Object[1];
+        params[0] = mockCatMsg;
+
+        /* broadcastCatCmdIntent method will get tested and 'sendBroadcast' would get invoked */
+        invokeNonStaticMethod(CatService.class, mCatService,
+            "broadcastCatCmdIntent", clsParams, params);
+
+        /* Since mock Context is used, sendBroadcast method is trapped
+         * and arguments can be examined. In the example below, first argument is an
+         * intent and is captured and examined for the flag. Parameters of no interest can
+         * be left as anyInt() or anyString() based on the method signature
+         */
+        ArgumentCaptor<Intent> intentCapture = ArgumentCaptor.forClass(Intent.class);
+        Mockito.verify(mContext).sendBroadcast(intentCapture.capture(), Mockito.anyString());
+
+        assertEquals(
+            ((Intent)intentCapture.getValue()).getFlags() & Intent.FLAG_RECEIVER_FOREGROUND,
+            Intent.FLAG_RECEIVER_FOREGROUND);
+    }
+
+    @Test
+    public void handleSessionEnd() {
+        invokeNonStaticMethod(CatService.class, mCatService, "handleSessionEnd", null, null);
+
+        ArgumentCaptor<Intent> intentCapture = ArgumentCaptor.forClass(Intent.class);
+        Mockito.verify(mContext).sendBroadcast(intentCapture.capture(), Mockito.anyString());
+
+        assertEquals(
+            ((Intent)intentCapture.getValue()).getFlags() & Intent.FLAG_RECEIVER_FOREGROUND,
+            Intent.FLAG_RECEIVER_FOREGROUND);
+    }
+
+    private Object invokeNonStaticMethod(Class clazz, Object caller, String method,
+                                               Class[] clsParams, Object[] params) {
+        try {
+            Method methodReflection = clazz.getDeclaredMethod(method, clsParams);
+            methodReflection.setAccessible(true);
+            return methodReflection.invoke(caller, params);
+        } catch (Exception e) {
+            Assert.fail(e.toString());
+            return null;
+        }
+    }
+}
diff --git a/tests/telephonytests/src/com/android/internal/telephony/cdma/CdmaInboundSmsHandlerTest.java b/tests/telephonytests/src/com/android/internal/telephony/cdma/CdmaInboundSmsHandlerTest.java
index 5786a70..f340208 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/cdma/CdmaInboundSmsHandlerTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/cdma/CdmaInboundSmsHandlerTest.java
@@ -20,6 +20,7 @@ import static com.android.internal.telephony.TelephonyTestUtils.waitForMs;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.fail;
 import static org.mockito.Matchers.any;
 import static org.mockito.Mockito.anyBoolean;
@@ -50,6 +51,7 @@ import com.android.internal.telephony.cdma.sms.SmsEnvelope;
 import com.android.internal.util.HexDump;
 import com.android.internal.util.IState;
 import com.android.internal.util.StateMachine;
+import com.android.internal.util.HexDump;
 
 import org.junit.After;
 import org.junit.Before;
@@ -226,4 +228,20 @@ public class CdmaInboundSmsHandlerTest extends TelephonyTest {
         verify(mContext, never()).sendBroadcast(any(Intent.class));
         assertEquals("IdleState", getCurrentState().getName());
     }
+
+    @Test
+    @MediumTest
+    public void testCtWdpParsing() {
+        transitionFromStartupToIdle();
+        String pdu = "000000000000FDEA00000000000000000100000000000000000000001900031" +
+                "040900112488ea794e074d69e1b7392c270326cde9e98";
+        SmsMessage msg = SmsMessage.createFromPdu(HexDump.hexStringToByteArray(pdu));
+        mSmsMessage.mWrappedSmsMessage = msg;
+        mCdmaInboundSmsHandler.sendMessage(InboundSmsHandler.EVENT_NEW_SMS,
+                new AsyncResult(null, mSmsMessage, null));
+        waitForMs(200);
+        assertEquals(msg.getTeleService(), SmsEnvelope.TELESERVICE_CT_WAP);
+        assertEquals("Test standard SMS", msg.getMessageBody());
+        assertNotNull(msg.getUserData());
+    }
 }
diff --git a/tests/telephonytests/src/com/android/internal/telephony/cdma/sms/BearerDataTest.java b/tests/telephonytests/src/com/android/internal/telephony/cdma/sms/BearerDataTest.java
new file mode 100755
index 0000000..e6e829a
--- /dev/null
+++ b/tests/telephonytests/src/com/android/internal/telephony/cdma/sms/BearerDataTest.java
@@ -0,0 +1,55 @@
+/* Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+package com.android.internal.telephony.cdma.sms;
+
+import android.test.AndroidTestCase;
+import java.lang.reflect.*;
+
+import static org.mockito.Mockito.mock;
+
+/**
+ * Test cases for BearerData testDecode7bitAscii
+ */
+public class BearerDataTest extends AndroidTestCase {
+    public void testDecode7bitAscii() throws Exception {
+        Method dm = BearerData.class.getDeclaredMethod("decode7bitAscii",
+                byte[].class, int.class, int.class);
+        dm.setAccessible(true);
+
+        // 56 bit test stream, assuming offset=1 byte, padding=6 bits
+        // numFields=7. So, I want 49 bits. The old logic would give
+        // 57 bits which is wrong
+        byte[] testbyte = new byte[7];
+        int offset = 1;
+        int numFields = 7;
+
+        dm.invoke(null, testbyte, offset, numFields);
+        assertTrue(true);
+    }
+}
diff --git a/tests/telephonytests/src/com/android/internal/telephony/cdma/sms/CdmaSmsTest.java b/tests/telephonytests/src/com/android/internal/telephony/cdma/sms/CdmaSmsTest.java
index 2e8c34b..7f0fed5 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/cdma/sms/CdmaSmsTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/cdma/sms/CdmaSmsTest.java
@@ -115,6 +115,14 @@ public class CdmaSmsTest extends AndroidTestCase {
     }
 
     @SmallTest
+    public void testRecipientAddress() throws Exception {
+        String pdu = "011a0000001002080d0003100160010610262d5ab500040401448888";
+        SmsMessage sms = SmsMessage.createFromEfRecord(0,
+                HexDump.hexStringToByteArray(pdu));
+        assertEquals("12222", sms.getRecipientAddress());
+    }
+
+    @SmallTest
     public void testUserData7bitGsm() throws Exception {
         String pdu = "00031040900112488ea794e074d69e1b7392c270326cde9e98";
         BearerData bearerData = BearerData.decode(HexDump.hexStringToByteArray(pdu));
@@ -263,6 +271,44 @@ public class CdmaSmsTest extends AndroidTestCase {
     }
 
     @SmallTest
+    public void testUserData7BitAsciiFeedback() throws Exception {
+        BearerData bearerData = new BearerData();
+        bearerData.messageType = BearerData.MESSAGE_TYPE_DELIVER;
+        bearerData.messageId = 0;
+        bearerData.hasUserDataHeader = false;
+        UserData userData = new UserData();
+        userData.payloadStr = "Test standard SMS";
+        userData.msgEncoding = UserData.ENCODING_7BIT_ASCII;
+        userData.msgEncodingSet = true;
+        bearerData.userData = userData;
+        byte[] encodedSms = BearerData.encode(bearerData);
+
+        BearerData revBearerData = BearerData.decode(encodedSms);
+        assertEquals(userData.msgEncoding, revBearerData.userData.msgEncoding);
+        assertEquals(userData.payloadStr.length(), revBearerData.userData.numFields);
+        assertEquals(userData.payloadStr, revBearerData.userData.payloadStr);
+
+        userData.payloadStr = "1234567";
+        revBearerData = BearerData.decode(BearerData.encode(bearerData));
+        assertEquals(userData.payloadStr, revBearerData.userData.payloadStr);
+        userData.payloadStr = "";
+        revBearerData = BearerData.decode(BearerData.encode(bearerData));
+        assertEquals(userData.payloadStr, revBearerData.userData.payloadStr);
+        userData.payloadStr = "12345678901234567890123456789012345678901234567890" +
+                "12345678901234567890123456789012345678901234567890" +
+                "12345678901234567890123456789012345678901234567890" +
+                "1234567890";
+        revBearerData = BearerData.decode(BearerData.encode(bearerData));
+        assertEquals(userData.payloadStr, revBearerData.userData.payloadStr);
+        userData.payloadStr = "Test \u007f illegal \u0000 SMS chars";
+        revBearerData = BearerData.decode(BearerData.encode(bearerData));
+        assertEquals("Test   illegal   SMS chars", revBearerData.userData.payloadStr);
+        userData.payloadStr = "More @ testing\nis great^|^~woohoo";
+        revBearerData = BearerData.decode(BearerData.encode(bearerData));
+        assertEquals(userData.payloadStr, revBearerData.userData.payloadStr);
+    }
+
+    @SmallTest
     public void testMonolithicOne() throws Exception {
         String pdu = "0003200010010410168d2002010503060812011101590501c706069706180000000701c108" +
                 "01c00901800a01e00b01030c01c00d01070e05039acc13880f018011020566";
@@ -987,4 +1033,30 @@ public class CdmaSmsTest extends AndroidTestCase {
             }
         }
     }
+
+    @SmallTest
+    public void testCdmaSmsAddressDigitalMode() throws Exception {
+        String str_test;
+        CdmaSmsAddress sms_addr;
+
+        str_test = "+00123456789";
+        sms_addr = CdmaSmsAddress.parse(str_test);
+        assertEquals(CdmaSmsAddress.DIGIT_MODE_8BIT_CHAR, sms_addr.digitMode);
+
+        str_test = "test@test.com";
+        sms_addr = CdmaSmsAddress.parse(str_test);
+        assertEquals(CdmaSmsAddress.DIGIT_MODE_8BIT_CHAR, sms_addr.digitMode);
+
+        str_test = "123456789";
+        sms_addr = CdmaSmsAddress.parse(str_test);
+        assertEquals(CdmaSmsAddress.DIGIT_MODE_4BIT_DTMF, sms_addr.digitMode);
+
+        str_test = "test_123@test.com";
+        sms_addr = CdmaSmsAddress.parse(str_test);
+        assertEquals(CdmaSmsAddress.DIGIT_MODE_8BIT_CHAR, sms_addr.digitMode);
+
+        str_test = " \t";
+        sms_addr = CdmaSmsAddress.parse(str_test);
+        assertEquals(CdmaSmsAddress.DIGIT_MODE_8BIT_CHAR, sms_addr.digitMode);
+    }
 }
diff --git a/tests/telephonytests/src/com/android/internal/telephony/dataconnection/DcTrackerTest.java b/tests/telephonytests/src/com/android/internal/telephony/dataconnection/DcTrackerTest.java
index 89d670c..7ee48d5 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/dataconnection/DcTrackerTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/dataconnection/DcTrackerTest.java
@@ -416,11 +416,13 @@ public class DcTrackerTest extends TelephonyTest {
         logd("DcTrackerTest +Setup!");
         super.setUp(getClass().getSimpleName());
 
+        doReturn(mSimRecords).when(mPhone).getIccRecords();
         doReturn("fake.action_detached").when(mPhone).getActionDetached();
         doReturn("fake.action_attached").when(mPhone).getActionAttached();
         doReturn(ServiceState.RIL_RADIO_TECHNOLOGY_LTE).when(mServiceState)
                 .getRilDataRadioTechnology();
         doReturn("44010").when(mSimRecords).getOperatorNumeric();
+        doReturn("44010").when(mPhone).getOperatorNumeric();
 
         mContextFixture.putStringArrayResource(com.android.internal.R.array.networkAttributes,
                 sNetworkAttributes);
@@ -443,6 +445,7 @@ public class DcTrackerTest extends TelephonyTest {
         ((MockContentResolver) mContext.getContentResolver()).addProvider(
                 Telephony.Carriers.CONTENT_URI.getAuthority(), mApnSettingContentProvider);
 
+        doReturn(true).when(mSubscriptionManager).isActiveSubId(anyInt());
         doReturn(true).when(mSimRecords).getRecordsLoaded();
         doReturn(PhoneConstants.State.IDLE).when(mCT).getState();
         doReturn(true).when(mSST).getDesiredPowerState();
@@ -569,6 +572,7 @@ public class DcTrackerTest extends TelephonyTest {
     @MediumTest
     public void testDataSetup() throws Exception {
 
+        doReturn(true).when(mSubscriptionManager).isActiveSubId(anyInt());
         mDct.setUserDataEnabled(true);
 
         mSimulatedCommands.setDataCallResult(true, createSetupDataCallResult());
diff --git a/tests/telephonytests/src/com/android/internal/telephony/dataconnection/TelephonyNetworkFactoryTest.java b/tests/telephonytests/src/com/android/internal/telephony/dataconnection/TelephonyNetworkFactoryTest.java
index 6d1cf8b..f31d195 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/dataconnection/TelephonyNetworkFactoryTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/dataconnection/TelephonyNetworkFactoryTest.java
@@ -106,6 +106,7 @@ public class TelephonyNetworkFactoryTest extends AndroidTestCase {
             subscriptionControllerMock =
                     new SubscriptionControllerMock(contextMock, telephonyRegistryMock, numPhones);
             subscriptionMonitorMock = new SubscriptionMonitorMock(numPhones);
+            subscriptionControllerMock.setActiveSubInfoCount(numPhones);
         }
 
         void die() {
@@ -309,12 +310,17 @@ public class TelephonyNetworkFactoryTest extends AndroidTestCase {
         if (ts.dcTrackerMock.getNumberOfLiveRequests() != 2) {
             fail("test 9,  LiveRequests != 2");
         }
+        ts.phoneSwitcherMock.setPhoneActive(phoneId, false);
+        waitABit();
 
         ts.subscriptionControllerMock.setDefaultDataSubId(subId);
         ts.subscriptionMonitorMock.notifyDefaultSubscriptionChanged(phoneId);
         ts.subscriptionMonitorMock.notifyDefaultSubscriptionChanged(altPhoneId);
         ts.subscriptionMonitorMock.notifyDefaultSubscriptionChanged(phoneId);
         waitABit();
+
+        ts.phoneSwitcherMock.setPhoneActive(phoneId, true);
+        waitABit();
         if (ts.dcTrackerMock.getNumberOfLiveRequests() != 3) {
             fail("test 10, LiveRequests != 3");
         }
diff --git a/tests/telephonytests/src/com/android/internal/telephony/imsphone/ImsPhoneCallTrackerTest.java b/tests/telephonytests/src/com/android/internal/telephony/imsphone/ImsPhoneCallTrackerTest.java
index eac6159..6c9a034 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/imsphone/ImsPhoneCallTrackerTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/imsphone/ImsPhoneCallTrackerTest.java
@@ -136,6 +136,17 @@ public class ImsPhoneCallTrackerTest extends TelephonyTest {
         doAnswer(new Answer<Void>() {
             @Override
             public Void answer(InvocationOnMock invocation) throws Throwable {
+                // trigger the listener on accept call
+                if (mImsCallListener != null) {
+                    mImsCallListener.onCallStarted(mImsCall);
+                }
+                return null;
+            }
+        }).when(mImsCall).accept(anyInt(), (ImsStreamMediaProfile) any());
+
+        doAnswer(new Answer<Void>() {
+            @Override
+            public Void answer(InvocationOnMock invocation) throws Throwable {
                 // trigger the listener on reject call
                 int reasonCode = (int) invocation.getArguments()[0];
                 if (mImsCallListener != null) {
@@ -364,7 +375,8 @@ public class ImsPhoneCallTrackerTest extends TelephonyTest {
         try {
             mCTUT.acceptCall(ImsCallProfile.CALL_TYPE_VOICE);
             verify(mImsCall, times(1)).accept(eq(ImsCallProfile
-                    .getCallTypeFromVideoState(ImsCallProfile.CALL_TYPE_VOICE)));
+                    .getCallTypeFromVideoState(ImsCallProfile.CALL_TYPE_VOICE)),
+                    (ImsStreamMediaProfile) any());
         } catch (Exception ex) {
             ex.printStackTrace();
             Assert.fail("unexpected exception thrown" + ex.getMessage());
@@ -812,4 +824,14 @@ public class ImsPhoneCallTrackerTest extends TelephonyTest {
         }
         verify(mImsPhone, times(1)).startOnHoldTone(nullable(Connection.class));
     }
+
+    @Test
+    @SmallTest
+    public void testCallResumeStateNotResetByHoldFailure() throws ImsException {
+        mCTUT.setSwitchingFgAndBgCallsValue(true);
+        if (mImsCallListener != null) {
+            mImsCallListener.onCallHoldFailed(mImsCall, new ImsReasonInfo(0, -1));
+        }
+        assertTrue(mCTUT.getSwitchingFgAndBgCallsValue());
+    }
 }
diff --git a/tests/telephonytests/src/com/android/internal/telephony/mocks/SubscriptionControllerMock.java b/tests/telephonytests/src/com/android/internal/telephony/mocks/SubscriptionControllerMock.java
index b14fc10..65f7e24 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/mocks/SubscriptionControllerMock.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/mocks/SubscriptionControllerMock.java
@@ -44,6 +44,7 @@ public class SubscriptionControllerMock extends SubscriptionController {
     final AtomicInteger mDefaultVoiceSubId = new AtomicInteger(INVALID_SUBSCRIPTION_ID);
     final ITelephonyRegistry.Stub mTelephonyRegistry;
     final int[][] mSlotIndexToSubId;
+    int mActiveSubInfoCount;
 
     public static SubscriptionController init(Phone phone) {
         throw new RuntimeException("not implemented");
@@ -84,7 +85,7 @@ public class SubscriptionControllerMock extends SubscriptionController {
         broadcastDefaultDataSubIdChanged(subId);
     }
 
-    private void broadcastDefaultDataSubIdChanged(int subId) {
+    protected void broadcastDefaultDataSubIdChanged(int subId) {
         // Broadcast an Intent for default data sub change
         Intent intent = new Intent(TelephonyIntents.ACTION_DEFAULT_DATA_SUBSCRIPTION_CHANGED);
         intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING);
@@ -129,7 +130,10 @@ public class SubscriptionControllerMock extends SubscriptionController {
     }
     @Override
     public int getActiveSubInfoCount(String callingPackage) {
-        throw new RuntimeException("not implemented");
+        return mActiveSubInfoCount;
+    }
+    public void setActiveSubInfoCount(int count) {
+        mActiveSubInfoCount = count;
     }
     @Override
     public int getAllSubInfoCount(String callingPackage) {
diff --git a/tests/telephonytests/src/com/android/internal/telephony/uicc/IccPhoneBookInterfaceManagerTest.java b/tests/telephonytests/src/com/android/internal/telephony/uicc/IccPhoneBookInterfaceManagerTest.java
index e71adc8..0ca8b73 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/uicc/IccPhoneBookInterfaceManagerTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/uicc/IccPhoneBookInterfaceManagerTest.java
@@ -146,7 +146,7 @@ public class IccPhoneBookInterfaceManagerTest extends TelephonyTest {
         values.put("newAnrs", "");
 
         boolean result = mIccPhoneBookInterfaceMgr.updateAdnRecordsWithContentValuesInEfBySearch(
-                IccConstants.EF_ADN, values , null);
+                IccConstants.EF_ADN, values , "1234");
 
         assertTrue(result);
     }
diff --git a/tests/telephonytests/src/com/android/internal/telephony/uicc/IccRecordsTest.java b/tests/telephonytests/src/com/android/internal/telephony/uicc/IccRecordsTest.java
index ac68f6c..045c6fc 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/uicc/IccRecordsTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/uicc/IccRecordsTest.java
@@ -33,12 +33,16 @@ import org.mockito.Mock;
 import static org.mockito.Mockito.*;
 import org.mockito.MockitoAnnotations;
 import org.junit.After;
+import static org.junit.Assert.assertEquals;
 import org.junit.Before;
 import org.junit.Test;
 import com.android.internal.telephony.TelephonyTest;
 
+import static com.android.internal.telephony.TelephonyTestUtils.waitForMs;
 import android.content.Context;
+import android.os.AsyncResult;
 import android.os.HandlerThread;
+import android.os.Message;
 
 public class IccRecordsTest extends TelephonyTest {
 
@@ -80,4 +84,19 @@ public class IccRecordsTest extends TelephonyTest {
     }
 
 
+    @Test
+    public void testGetSmsCapacityOnIcc() {
+        // set the number of records to 500
+        int[] records = new int[3];
+        records[2] = 500;
+        Message fetchCapacityDone = mIccRecords.obtainMessage(
+                IccRecords.EVENT_GET_SMS_RECORD_SIZE_DONE);
+        AsyncResult.forMessage(fetchCapacityDone, records, null);
+        fetchCapacityDone.sendToTarget();
+
+        // verify whether the count is 500
+        waitForMs(200);
+        assertEquals(mIccRecords.getSmsCapacityOnIcc(), 500);
+    }
+
 }
diff --git a/tests/telephonytests/src/com/android/internal/telephony/uicc/UiccCardApplicationTest.java b/tests/telephonytests/src/com/android/internal/telephony/uicc/UiccCardApplicationTest.java
index 62b1fc9..458f080 100644
--- a/tests/telephonytests/src/com/android/internal/telephony/uicc/UiccCardApplicationTest.java
+++ b/tests/telephonytests/src/com/android/internal/telephony/uicc/UiccCardApplicationTest.java
@@ -166,6 +166,28 @@ public class UiccCardApplicationTest extends TelephonyTest {
 
     @Test
     @SmallTest
+    public void testCheckIsPersoLocked() {
+        mUiccCardAppStatus.app_state = IccCardApplicationStatus.AppState
+               .APPSTATE_SUBSCRIPTION_PERSO;
+        mUiccCardAppStatus.perso_substate = IccCardApplicationStatus.PersoSubState
+                .PERSOSUBSTATE_SIM_NETWORK;
+        Message mCardAppUpdate = mHandler.obtainMessage(UICCCARDAPP_UPDATE_EVENT);
+        setReady(false);
+        mCardAppUpdate.sendToTarget();
+        waitUntilReady();
+        assertTrue(mUiccCardApplication.isPersoLocked());
+
+        mUiccCardAppStatus.perso_substate = IccCardApplicationStatus.PersoSubState
+                .PERSOSUBSTATE_READY;
+        setReady(false);
+        mCardAppUpdate = mHandler.obtainMessage(UICCCARDAPP_UPDATE_EVENT);
+        mCardAppUpdate.sendToTarget();
+        waitUntilReady();
+        assertFalse(mUiccCardApplication.isPersoLocked());
+    }
+
+    @Test
+    @SmallTest
     public void testGetSetIccLockedEnabled() {
         assertFalse(mUiccCardApplication.getIccLockEnabled());
         Message mLockEnabled = mHandler.obtainMessage(UICCCARDAPP_ENABLE_LOCK_EVENT);
